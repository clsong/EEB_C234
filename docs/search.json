[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EE BIOL C234",
    "section": "",
    "text": "Weclome\nWelcome to EE BIOL C234: Practical Computing for Evolutionary Biologists and Ecologists—or, as I like to say, a crash course in “computational Kung-Fu”.",
    "crumbs": [
      "Weclome"
    ]
  },
  {
    "objectID": "index.html#course-info",
    "href": "index.html#course-info",
    "title": "EE BIOL C234",
    "section": "Course Info",
    "text": "Course Info\n\nWhere and When: We’ll be meeting Mondays and Wednesdays, 11:00 AM to 11:50 AM, in Botany 108.\nOffice Hours: Wednesdays, 3 PM to 4 PM, in Botany 210H.\nThe Grind: Yes, there will be weekly assignments (non-graded) and 3 PSETs. If you want to build computational muscle, you’re going to have to sweat a bit.\nWhat to Bring: Just your laptop and a healthy dose of intellectual curiosity. If you have played with R before, great; if not, don’t worry—you’ll pick it up.\nCourse Material: This lecture note will be updated as the course progresses. \n\nThis is the inaugural run of this course for me. So if I’m losing you, boring you, talking too fast, too slow, whatever – speak up! Your feedback is my compass.",
    "crumbs": [
      "Weclome"
    ]
  },
  {
    "objectID": "index.html#how-to-use-the-lecture-notes",
    "href": "index.html#how-to-use-the-lecture-notes",
    "title": "EE BIOL C234",
    "section": "How to Use the Lecture Notes",
    "text": "How to Use the Lecture Notes\nYour left sidebar is your map to the course, showing all lectures—just a click away. On the right, you’ll see a table of contents specific to each lecture.\nIn this course, code examples will appear in blocks like this:\n\n1x &lt;- 1+1\n2x^2\n\n\n1\n\nCalculate 1+1 and assign it to the variable x.\n\n2\n\nCalculate the square of x.\n\n\n\n\nSee the little circle on the right? Hover over it for a quick explanation of the code. When you hover over the code block itself, you’ll also spot a “copy” button—perfect for copying and pasting it into your R console to try it out yourself (fun fact: that’s how a large portion of coding is done in real life).\nTo show stepped progress, we’ll often add to existing code blocks. New additions are highlighted for clarity. For example:\n\nx &lt;- 1+1 \nx^2 \n1x^3\n\n\n1\n\nCalculate the cube of x.\n\n\n\n\nYou’ll find key computational tools and R packages highlighted in purple (e.g., GitHub and ggplot2). R functions are indicated in red and always include parentheses, such as sum().\nThroughout the course, expect tips, tricks, and even a few fun facts sprinkled in. While not essential, these extras might give you an edge or deeper insight. Some of them are collapsible, so you can click to expand and explore them at your own pace. Look out for these in green boxes, like this:\n\n\n\n\n\n\nTips\n\n\n\n\n\n\n\n\nAs advertised, this is a tips box.\n\n\n\n\n\nI have included many exercises throughout the notes. These are your chance to practice what you’ve learned. Just fill in ____ with the correct answer and then run the code block to check your work. If you ever get stuck, the Solution is just next to it. For example,\n\nExercise: Calculate 2+2Solution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Weclome"
    ]
  },
  {
    "objectID": "01_intro.html",
    "href": "01_intro.html",
    "title": "\n1  Course goal\n",
    "section": "",
    "text": "1.1 Why Bother with This Course in the Age of AI?\nAlright, let’s cut to the chase. You signed up to study Ecology and Evolutionary Biology, not Computer Science. You probably envision yourself out in the field, knee-deep in mud, observing the subtle interactions of ecosystems—not stuck behind a screen, wrestling with semicolons and syntax errors. And now, with these fancy new AI tools that seem to do everything but your taxes, you might be wondering: why bother learning this computational stuff at all? Can’t a chatbot handle it all—generate analyses, whip up some plots, and call it a day?\nIt’s a fair question. Technology is reshaping everything, and science is no exception. But here’s the thing: just as biologists in the past had to master the microscope, today’s biologists need a strong foundation in computing. This course isn’t about turning you into a programmer; it’s about giving you the keys to harness technology effectively—so you’re steering the ship, not just along for the ride.\nBefore any anxiety sets in, let me assure you that this course is not gonna be a sink-or-swim experience. We’ll embark on a guided journey into computing, building your skills step by step. Think of it as learning a new language—with much simpler grammar, thankfully. We’ll use concrete example with annotated codes and hands-on exercises to support you along the way.\nAnd about those AI tools? Yes, they can be incredibly useful, no doubt. But relying on them blindly, without understanding the underlying principles, is like cooking from a recipe in a language you barely know. Sure, you might finish the dish, but there’s a good chance you’ll miss something critical—maybe misinterpret a step, add the wrong ingredient, or be puzzled by the end result. Computational literacy helps you to catch when the AI is leading you astray, saving you from headaches (and potentially flawed results) down the line.\nI get the temptation of the “easy button”, we all do. But investing in these skills now will pay off many times over. You’ll be a more efficient, more confident researcher—and, frankly, it will boost your chances of publishing in those coveted high-profile journals.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Course goal</span>"
    ]
  },
  {
    "objectID": "01_intro.html#what-youll-learn",
    "href": "01_intro.html#what-youll-learn",
    "title": "\n1  Course goal\n",
    "section": "\n1.2 What You’ll Learn",
    "text": "1.2 What You’ll Learn\nWe’ll cover the following topics, which are, in my view, the most essential computing skills for ecologists today. These are the things I wish I knew when I started grad school – it would have saved me so much time and frustration!\n\n1.2.1 Fluency with R\nWhat is our weapon of choice in this course? The R programming language. It is not the most well-polished language. It is not the fastest language. It is not the most user-friendly language. So, why R? Well, it is the lingua franca in our community. The computational tools in ecology are largely R-based. So, if you want to tap into this wealth, you’ll need a working knowledge of R.\n\n\n\n\n\n\nFeeling Adventurous?\n\n\n\n\n\nNot sold on R? You could try Julia, a newer language that’s faster, more elegant, and gaining popularity. The syntax is similar enough to R to make it a relatively easy transition, and it can even load R packages, so you can have the best of both worlds.\n\n\n\nR has also evolved dramatically in the past decade with the rise of the tidyverse suite. When I started grad school, I absolutely hated using R. But the tidyverse transformed that experience. It introduced a coherent way of handling and visualizing data—one that feels logical and intuitive. I firmly believe it’s the right approach to data manipulation and plotting.\n\n\n\n\n\n\nHeroes Behind the Tidyverse\n\n\n\n\n\nThe tidyverse revolution is largely thanks to Hadley Wickham, whose contributions earned him the COPSS Presidents’ Award, the top honor in statistics.\nBut it’s not a one-person show—the tidyverse thrives because of a vibrant community united by a shared vision (link).\n\n\n\n\n1.2.2 Crafting Publication-Ready Figures\nWith ggplot2, you’ll learn the Grammar of Graphics, one of the most powerful plotting systems out there. Beyond just producing high-quality figures, it will teach you a structured approach to data visualization.\nWhile ggplot2 is powerful, its defaults aren’t always perfect. We’ll cover design principles that enhance both the appeal and informativeness of your figures. This skill is quite useful—after all, figures often make the first impression on your readers. By the end of the course, you’ll be capable of creating figures like this: By the end of the course, you’ll be capable of creating figures like this:\n\n\nby Cédric Scherer\n\n\n1.2.3 The Art of Data Wrangling\nIn our daily research, data is rarely neat. Before you can start analyzing, you’ll likely spend hours organizing it into a usable format. Fortunately, dplyr and tidyr simplify this process, turning data wrangling into a clear, logical workflow.\nTo get a quick taste, let us imagine describing your morning routine. In base R, it might look like a convoluted nest of functions:\n\neat(dressed(shower(brush(wakeup(you)))))\n\nOr, a series of perplexing intermediate variables:\n\nyou_w &lt;- wakeup(you)\nyou_bw &lt;- brush(you_w)\nyou_sbw &lt;- shower(you_bw)\n...\n\nWith dplyr, however, it transforms into a straightforward, logical flow:\n\nyou |&gt; \n  wakeup() |&gt; \n  brush() |&gt; \n  shower() |&gt; \n  get_dressed() |&gt; \n  eat() \n\nIn the tidyverse ecosystem, each step of data manipulation is easy to write and, more importantly, easy to follow when reading other people’s code. We’ll introduce you to a core set of verbs—fewer than ten—that will handle over 90% of everyday tasks. You see, coding languages are indeed simpler than human languages!\n\n1.2.4 Scientific typsetting\nYes, Microsoft Word is great. But when it comes to updating figures, managing references, or maintaining consistent layouts, it can quickly turn into a labyrinthine headache. The core issue is that Word is a WYSIWYG editor—What You See Is What You Get (a weird acronym, I know).\nThe problem with WYSIWYG editors is that they often require manual tweaks—nudging an image here, adjusting a margin there—which not only consumes valuable time but also opens the door to errors. This is why separating content from layout is a strategy worth adopting. Instead of wrestling with formatting, you focus on the substance of your work—the data, the analysis, the insights—and let the tools handle the presentation.\nWhile there are several tools for this purpose (including the notorious LaTeX), we’ll focus on Quarto, a modern document preparation system tailored for researchers. Quarto allows you to seamlessly integrate code, references, and figures, producing professional outputs in submission-ready formats like Word or LaTeX with minimal effort. By the end of this course, you’ll be able to generate documents like this with a single click in R:\n\n\nby LaPreprint\n\n\n\n\n\n\n\nProfessional Typesetting\n\n\n\n\n\nWhile Quarto is powerful, sometimes you need specialized tools for optimal layout. LaTeX is one option, but it can feel outdated and cumbersome. We’ll briefly explore Typst, a modern alternative that offers the sophistication of LaTeX without the steep learning curve. It is also much faster and provided user-friendly interface for bebuggging. I firmlt believe Typst will replace LaTeX in the near future.\n\n\n\n\n1.2.5 Reproducible Research\nAs a data editor for a journal, I’m often struck by how many papers are challenging to reproduce—which I see as a huge problem for science. In this course, you’ll learn to make your research fully reproducible, which benefits not only the scientific community but also you—it makes it easier to revisit and build upon your work.\n\n\nPhD comics by Jorge Cham\n\nWe’ll get into version control using Git and GitHub, tools that help you track changes, back up your work, and collaborate effectively. Additionally, we’ll cover specific techniques in R that support reproducible workflows, ensuring your research stands on a solid foundation.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Course goal</span>"
    ]
  },
  {
    "objectID": "01_intro.html#course-plan-tentative",
    "href": "01_intro.html#course-plan-tentative",
    "title": "\n1  Course goal\n",
    "section": "\n1.3 Course Plan (Tentative)",
    "text": "1.3 Course Plan (Tentative)\n\n1.3.1 Introduction to R and RStudio\n\nInstalling R and RStudio\nNavigating the RStudio interface\nBasic R syntax and operations\nIntroduction to R packages and the tidyverse\n\nBasic Data Types: tibble and vector\n\n\n1.3.2 Introduction to ggplot2\n\n\nThe Grammar of Graphics concept\nCreating basic plots: scatter plots, line graphs, histograms, boxplots\nCustomizing plots with aesthetics, themes, and labels\nSaving and exporting plots\n\n1.3.3 Core dplyr Verbs for Data Manipulation\n\nUsing the pipe operator (|&gt;) for streamlined code\n\nfilter(): subsetting rows based on conditions\n\nselect(): choosing specific columns\n\nmutate(): creating and transforming variables\n\ngroup_by() and summarize(): aggregating and summarizing data\n\n1.3.4 Advanced ggplot2 Techniques\n\nDesign principles based on Fundamentals of Data Visualization by Claus O. Wilke\nAnnotation with ggrepel and gghighlight for labeling and highlighting key data\nEnhanced text formatting with ggtext\n\nMulti-panel plots with patchwork\n\nInteractive plots with ggiraph\n\nAnimated plots with gganimate to visualize changes over time\nHandling overplotting with ggpointdensity and ggdensity for dense scatter plots\nUncertainty visualization with ggdist and ggridgesmaterial\nApplying beautiful themes\nHow to adjust figures for presentations\n\n1.3.5 Importing and Cleaning Data\n\nImporting data with readr\n\nCleaning data with janitor\n\nHandling missing data\nHandling dates with lubridate\n\nJoining data with left_join()\n\n\n1.3.6 Making R Run Faster\n\n\nFaster data wrangling with dtplyr for speed improvements\nFunctional programming with purrr\n\nParallel computing with furrr to utilize multiple cores for concurrent execution\n\n1.3.7 Introduction to Quarto\n\nSetting up Quarto and integrating it with RStudio\nDocument structure and YAML metadata\nBlocks and chunk options: controlling code execution and output\nReference management with bibtex\n\nGenerating outputs: rendering documents to HTML, PDF, and Word formats\n\n1.3.8 Best Practices for Reproducible Research\n\nVersion control with Git and GitHub using RStudio\n\nUsing Quarto for reproducible reports: integrating code, analysis, and narrative text\ncreating reproducible environments and managing dependencies with renv\n\n\n1.3.9 How to Use AI in Coding\n\nIntroduction to GitHub Copilot",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Course goal</span>"
    ]
  },
  {
    "objectID": "01_intro.html#what-we-wont-cover",
    "href": "01_intro.html#what-we-wont-cover",
    "title": "\n1  Course goal\n",
    "section": "\n1.4 What We Won’t Cover",
    "text": "1.4 What We Won’t Cover\nThere’s a vast universe of computing out there, and we have to draw the line somewhere (before we all get lost in a black hole of code). There’s a reason why programmers in the Silicon Valley are paid so well—computing is hard! Here are some intriguing areas we won’t cover in this course, but I encourage you to explore them in the future:\n\nAdvanced Statistics and Machine Learning: These areas are extensive and deserve dedicated courses. To dive deeper into the world of algorithms and data models, I’d recommend starting with Tidymodels, which shares the same design philosophy as the tidyverse and should make for a smooth transition.\nWriting R Packages: Creating your own R packages is super useful, but might be overkill for our current adventure. If you’re interested in trying this, check out Hadley Wickham’s book R Packages as a starting point.\nHigh-Performance Computing and Big Data Analytics: Working with massive datasets and supercomputers is exciting (who doesn’t want to feel like they’re in a NASA control room?), but it often requires specialized knowledge and environment-specific setups. Plus, ecological datasets aren’t usually large enough to make your laptop break a sweat. We’ll stick to tools that run on a standard machine. If you’re eager to unleash the Kraken of computing power, UCLA’s Hoffman2 Cluster has you covered with detailed guidelines.\nBuilding Personal Websites: Maintaining a professional personal website is important for academics—it’s like your digital business card. Quarto makes it quite easy to set one up, but we won’t cover the details in this course. If you’re intrested, I’d recommend exploring the Quarto documentation on making websites.\nOther Programming Languages: Python, Julia, and friends are like the enticing dessert menu after a big meal—tempting but perhaps best saved for another time. As mentioned earlier, transitioning from R to Julia is relatively straightforward, so you can always explore other languages when you’re ready to expand your coding palate.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Course goal</span>"
    ]
  },
  {
    "objectID": "02_R_basics.html",
    "href": "02_R_basics.html",
    "title": "2  Basics of R and RStudio",
    "section": "",
    "text": "2.1 Installing R and RStudio\nLet’s begin at the most logical starting point: getting the software installed. To get started, I recommend this comprehensive installation guide that will walk you through the process seamlessly.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basics of R and RStudio</span>"
    ]
  },
  {
    "objectID": "02_R_basics.html#why-do-we-need-rstudio",
    "href": "02_R_basics.html#why-do-we-need-rstudio",
    "title": "2  Basics of R and RStudio",
    "section": "2.2 Why Do We Need RStudio?",
    "text": "2.2 Why Do We Need RStudio?\nThink of R as a high-performance engine—capable of incredible feats but not particularly user-friendly on its own. RStudio is the sleek vehicle that lets you harness that power efficiently. While you could interact with R through a basic terminal, RStudio’s interface smoothly handles the otherwise clunky commands and makes certain tasks—like visualizing results or managing code—remarkably more accessible.\n\n\n\n\n\n\nAlternative Options Worth Considering\n\n\n\n\n\nDespite RStudio’s popularity, it is hardly the only game in town. VSCode has emerged as a popular alternative—a versatile, general-purpose IDE that supports multiple programming languages. It’s well-designed, feature-rich, and, importantly, free and open-source. Personally, I use VSCode for most of my R programming work.\nAnother option on the horizon is Positron, developed by the same innovative team behind RStudio. It’s the modern evolution of RStudio, currently in beta but already showing great promise. It will eventually replace RStudio as the go-to IDE for R programming.\n\n\n\nRStudio is an incredible well-designed software that makes your life easier when working with R (and Python). It has a lot of features that make your life easier. We’ll explore many of these features as we progress, starting with making your R code look better.\n\n\n\n\n\n\nMaking Your Code look prettier\n\n\n\nOne of the subtle joys of programming is crafting code that’s not only functional but also aesthetically pleasing. To enhance the readability of your R scripts, consider installing the Fira Code font. Instruction can be found here and here.\nAnother way to make your code more readable is to format the codes according to the tidyverse style guide. Of course, no one wants to memorize all. Luckily, you can use the styler package to do this as an addin in RStudio (link).",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basics of R and RStudio</span>"
    ]
  },
  {
    "objectID": "02_R_basics.html#getting-r-to-work-for-you",
    "href": "02_R_basics.html#getting-r-to-work-for-you",
    "title": "2  Basics of R and RStudio",
    "section": "2.3 Getting R to Work for You",
    "text": "2.3 Getting R to Work for You\nIn the grand tradition of programming tutorials, let’s start with the classic “Hello, World!”—a humble beginning to our journey with R.\n\n1print(\"Hello, World!\")\n\n\n1\n\nThe print() function displays the text within on the console.\n\n\n\n\n[1] \"Hello, World!\"\n\n\nNext, you can use R as a straightforward calculator:\n\n3 + 2\n\n[1] 5\n\n\nYou can also store results in variables (so you can use them later):\n\n1x &lt;- 3 + 2\n2x\n\n\n1\n\nAssigns the value of 3 + 2 to the variable x.\n\n2\n\nThe x displays the value of x on the console.\n\n\n\n\n[1] 5\n\n\n\n\n\n\n\n\nWhy does R use &lt;-?\n\n\n\n\n\nIn R, &lt;- is for assignment while = is for function arguments. You can technically use = for assignment in almost all cases, meaning x &lt;- 3 + 2 is equivalent to x = 3 + 2. But then why does R continue to favor &lt;-?\nOne reason is conceptual clarity. In R, the distinction between assignment and function arguments is explicit, providing a cleaner syntax and helping avoid ambiguity in complex code. By differentiating assignment with &lt;-, R signals that an action is being performed, where data is transferred from one entity to another. This reinforces the principle that assignment and function arguments are inherently distinct constructs.\nA second reason is flexibility. R allows for the reverse assignment arrow, -&gt;, which lets you assign values in the opposite direction. For instance, 3 -&gt; x assigns the value 3 to x, a feature that can sometimes be handy.\nBut why don’t most other languages use a similar convention? One factor is typing efficiency: &lt;- requires three keystrokes, while = only requires one (although you eventually get used to it). However, there’s also a historical element here: early keyboards designed for statistical computing actually had a dedicated &lt;- key, which made the operator as convenient as = (source):\n\n\n\nFrom https://dcl-prog.stanford.edu/data-structure-basics.html\n\n\n\n\n\n\nExercise\n\nCreate a variable y and assign it the value of 5 * 3. Then display the value of y on the console.\n\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nCreate a variable z that is half of the value of y, and then display the value of z on the console.\n\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basics of R and RStudio</span>"
    ]
  },
  {
    "objectID": "02_R_basics.html#using-ai-in-rstudio",
    "href": "02_R_basics.html#using-ai-in-rstudio",
    "title": "2  Basics of R and RStudio",
    "section": "2.4 Using AI in RStudio",
    "text": "2.4 Using AI in RStudio\nThere are many basic functions in R that you can use. For example, the sqrt() function calculates the square root of a number. I know that it could be annoying to remember all the functions, but luckily we have the powerful AIs to help us. It is pretty easy to use Copilot, a powerful AI tool developed by Github, to get the function you need. It is straightforward to use it in RStudio (link).\nHowever, AIs can be unreliable sometimes. To make sure it works, you can always use the ? to double check. For example, to see the documentation R has on the sqrt() function, you can use the following code:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn addition, you should check some simple cases to make sure the function works as expected. For example, you can use the following code to check the sqrt() function:\n\nsqrt(1) == 1\n\n[1] TRUE\n\nsqrt(4) == 2\n\n[1] TRUE",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basics of R and RStudio</span>"
    ]
  },
  {
    "objectID": "02_R_basics.html#installing-packages",
    "href": "02_R_basics.html#installing-packages",
    "title": "2  Basics of R and RStudio",
    "section": "2.5 Installing Packages",
    "text": "2.5 Installing Packages\n\nStandard approachpak methodpacman method\n\n\nTo unlock R’s full potential, you’ll often need to install additional packages—think of them as apps that extend your smartphone’s capabilities. This is a one-time process for each package on your computer. For example, to install the ggplot2 package:\n\ninstall.packages(\"ggplot2\")\n\nAfter that, simply load it when you need it:\n\nlibrary(ggplot2)\n\n\n\n\n\n\n\nA Quirk to Watch Out For\n\n\n\n\n\nThis is the first design inconsistencies when using R: when installing a package, you enclose its name in quotes, but when loading it, you don’t. It’s a small quirk, but one that can trip you up if you’re not careful (speaking from experience :-(\nThere will be many others along the way. I will try to point them out as we go along.\n\n\n\n\n\nNotably, not all packages are on CRAN. For example, many of them are on GitHub, GitLab, or other platforms. To install these packages, you can use the pak package. For example, to install the ggthemr package from GitHub:\n\n1# install.packages(\"pak\")\n2pak::pkg_install(\"cttobin/ggthemr\")\n\n\n1\n\nInstall the pak package.\n\n2\n\nInstall the ggthemr package from GitHub.\n\n\n\n\nWhat is this mysterious :: here? It simply means that we are loading the pkg_install() function from the pak package. It allows you to access a function from a package without loading the entire package. This can help avoid conflicts with other packages that might have a similarly named function (which is a huge source for hidden errors!).\nI highly recommend this approach, because it clearly document which dependencies it comes with and it provides a universal way to install packages from different sources.\n\n\nThere is another popular strategy. Consider using the pacman package. It automatically detects if the pointed package is installed and installs it if it’s not, and then load it. Here’s how you can use it:\n\n1# install.packages(\"pacman\")\n2pacman::p_load(ggplot2)\n\n\n1\n\nKeep in mind that you’ll need to install pacman first, as it’s not part of R’s base packages.\n\n2\n\nUse p_load() to install and load the ggplot2 package in one go.\n\n\n\n\nThis can greatly simplify things when sharing code. You don’t have to wonder whether a particular library is installed on someone else’s system—p_load() handles it gracefully.\n\n\n\n\nExercise: Installing Packages\nInstall the package gt using the standard method, the pak method, and the pacman method.\n\nExercise\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basics of R and RStudio</span>"
    ]
  },
  {
    "objectID": "02_R_basics.html#meet-the-tidyverse",
    "href": "02_R_basics.html#meet-the-tidyverse",
    "title": "2  Basics of R and RStudio",
    "section": "2.6 Meet the Tidyverse",
    "text": "2.6 Meet the Tidyverse\nAs stated in its official website:\n\nThe tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures.\n\nInstalling it may take a bit:\n\ninstall.packages(\"tidyverse\")\n\nOnce done, loading it is straightforward and a common part of most R scripts (I usually begin nearly all my scripts with this line):\n\nlibrary(tidyverse)\n\nWarning: package 'tidyr' was built under R version 4.2.3\n\n\nWarning: package 'readr' was built under R version 4.2.3\n\n\nWarning: package 'dplyr' was built under R version 4.2.3\n\n\nWarning: package 'stringr' was built under R version 4.2.3\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ lubridate 1.9.3     ✔ tibble    3.2.1\n✔ purrr     1.0.2     ✔ tidyr     1.3.1\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nAs you can see, Looking at the message generated by executing the above line, we see that nine packages are now loaded. They are called ggplot2, tibble, and so on. We will get to know these in more detail throughout the class.\n\n\n\n\n\n\nWhat does conflicts message mean?\n\n\n\n\n\nAs you can see from the message, it shows what conflicts are there. The two conflicts are horrible design choices in tidyverse. Many mysterious bugs happen because of these conflicts. To avoid these, you can use the following code:\n\n1library(conflicted)\n2library(tidyverse)\n3conflict_prefer(\"filter\", \"dplyr\")\n4conflict_prefer(\"lag\", \"dplyr\")\n\n\n1\n\nLoad the conflicted package.\n\n2\n\nLoad the tidyverse package.\n\n3\n\nThis code says that if there is a conflict on filter, always prefer dplyr.\n\n4\n\nThis code says that if there is a conflict on lag, always prefer dplyr.\n\n\n\n\nAnother way is to just write your code using the package::funcion() format:\n\ndplyr::filter()\ndplyr::lag()\n\nGiven how often you’ll use these functions, I find it annoying with this approach. But it’s a personal choice.\n\n\n\n\n\n\n\n\n\nWant to avoid the annoying messages?\n\n\n\n\n\nIf you do not want to see the messages (although I do not recommend), you can use the suppressPackageStartupMessages() function. For example, you can use the following code to load the tidyverse package:\n\nsuppressPackageStartupMessages(library(tidyverse))\n\nThis approach hides the typical start-up output, though it remains entirely optional.\n\n\n\nWe’ll rely on the tidyverse extensively throughout this course.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basics of R and RStudio</span>"
    ]
  },
  {
    "objectID": "03_data_structure.html",
    "href": "03_data_structure.html",
    "title": "3  Basic Data Structure",
    "section": "",
    "text": "3.1 Vector\nA data structure is an orderly, efficient way to store and retrieve data. While it may feel a bit abstract if you’re new to coding, think of these structures as the “nouns” in your programming language (with data wrangling serving as the “verbs”).\nR has provided many data structures. Fortunately, nine times out of ten, you’ll only need to worry about two: vector and tibble.\nA vector is a one-dimensional array—like a row of seats in a movie theater that only allows one type of audience member, be they numeric, character, or logical. We create them with the c() function. For example:\n1numbers &lt;- c(1, 2, 3, 4, 5)\n2numbers\n\n\n1\n\nCreate a vector of numbers from 1 to 5.\n\n2\n\nDisplay the numbers vector.\n\n\n\n\n[1] 1 2 3 4 5\nVectors form the backbone of R scripts. They’re how you can store the number of penguins wandering around Antarctica, keep track of class attendance, or tally cars on the highway. A key detail: everything in a vector must share the same type. Some common types are:\nBelow, we make a few different vectors to illustrate these types:\n1numbers &lt;- c(1.1, 2.2, 3.3, 4.4, 5.5)\n2characters &lt;- c(\"a\", \"b\", \"c\")\n3logicals &lt;- c(TRUE, FALSE, TRUE)\n4factors &lt;- factor(c(\"a\", \"b\", \"c\"))\n\n\n1\n\nCreate a vector of numbers from 1 to 5.\n\n2\n\nCreate a vector of characters.\n\n3\n\nCreate a vector of logicals.\n\n4\n\nCreate a vector of factors.\nWe can also extract data from a vector using the square brackets []. For example:\n1numbers[1]\n2characters[2]\n\n\n1\n\nExtract the first element from the numbers vector.\n\n2\n\nExtract the second element from the characters vector.\n\n\n\n\n[1] 1.1\n[1] \"b\"\nNote that the index starts from 1, not 0. This is a common source of confusion for those coming from languages like Python or C. I personally prefer the 1-based index, as this is more intuitive.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Data Structure</span>"
    ]
  },
  {
    "objectID": "03_data_structure.html#vector",
    "href": "03_data_structure.html#vector",
    "title": "3  Basic Data Structure",
    "section": "",
    "text": "What does c() stand for\n\n\n\n\n\nc() means “combine.” Yes, it’s a slightly cryptic name for what you’ll soon be typing all the time, but you’ll get used to it.\n\n\n\n\n\nnumeric (like 3.14 or 42)\ncharacter (like “Hello” or “World”)\nlogical (TRUE or FALSE)\nfactor (categorical data)\n\n\n\n\n\n\n\n\n\nBe aware of data types\n\n\n\nR automatically assigns the data type for each vector, which can save time but also lead to (unwanted) surprises. For instance, sometimes 1 appears as a character rather than a number—something that can introduce annoying bugs. Avoid headaches by checking data types with class(). For example:\n\nclass(numbers) \n\n[1] \"numeric\"\n\n\nA horror story (not in R but in Excel) is that the auto-convert feature messes up gene names like SEPT4 to 4-Sept (datatype from character to datetime). This has affected a ton of genetic papers. So, always be aware of the data types!\n\n\n\n\n\n\nExercise\n\nCreate a vector of numbers from -1 to -3, and then extract the second element.\n\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nCreate a vector of characters with your name and surname.\n\n\nExercise\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nCreate a vector of logicals by flipping a coin three times.\n\n\nExercise\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Data Structure</span>"
    ]
  },
  {
    "objectID": "03_data_structure.html#tibble",
    "href": "03_data_structure.html#tibble",
    "title": "3  Basic Data Structure",
    "section": "3.2 Tibble",
    "text": "3.2 Tibble\nA tibble (brought to you by the tidyverse) is essentially a set of vectors bound together in columns—like a multi-row, multi-column theater, where each column houses a single data type.\n\nAs a simple xample,\n\n1library(tidyverse)\n2tibble(\n3    x = c(1, 2, 3),\n4    y = c(\"a\", \"b\", \"c\"),\n5    z = c(TRUE, FALSE, TRUE)\n6)\n\n\n1\n\nLoad the tidyverse package, as tibble is from it.\n\n2\n\nCreate a tibble.\n\n3\n\nCreate the first column as a vector of numbers from 1 to 3.\n\n4\n\nCreate the second column as a vector of characters.\n\n5\n\nCreate the third column as a vector of logicals.\n\n6\n\nAlways remember to close the function with a parenthesis.\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\nAnother way to write tibble\n\n\n\n\n\nThere is another equivalent way of writing it rowwisely. For example,:\n\n1tribble(\n2  ~x, ~y,\n3  1, \"a\",\n  2, \"b\", \n  3, \"c\"\n)\n\n\n1\n\nCreate a tibble rowwisely (note the function name is different from tibble).\n\n2\n\nDefine the column names.\n\n3\n\nDefine the first row.\n\n\n\n\n\n  \n\n\n\nThis is perfect when typing in smaller datasets by hand.\n\n\n\nTibbles come with plenty of benefits over base R’s classic data frame—particularly in how they track and preserve data types. You’ll notice each column explicitly labeled as dbl (double) or chr (character), which can save you from those frustrating mysteries where your numeric data gets disguised as text.\nTibbles also enforce a neat and consistent data layout, called Tidy Data, which is a godsend when you’re dealing with other people’s messy spreadsheets. Quoting from Hadley Wickham (link):\n\nTidy datasets are easy to manipulate, model and visualize, and have a specific structure: each variable is a column, each observation is a row, and each type of observational unit is a table.\n\n\n\n\nFrom https://r4ds.hadley.nz/data-tidy.html\n\n\nWe will learn more about working with tibble more in the next sections, but for now, let’s move on to our example dataset.\n\nExercise\nCreate a tibble with the following columns:\n\nname with your name and surname\nage with your age\nis_student with a logical value\n\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Data Structure</span>"
    ]
  },
  {
    "objectID": "03_data_structure.html#our-example-dataset-penguins",
    "href": "03_data_structure.html#our-example-dataset-penguins",
    "title": "3  Basic Data Structure",
    "section": "3.3 Our example dataset: penguins",
    "text": "3.3 Our example dataset: penguins\nWe’ll soon learn how to import data (another comedic ordeal in itself), but for now, let’s borrow the penguins dataset from the palmerpenguins package. It covers three penguin species—Adelie, Chinstrap, and Gentoo—and gives us some useful variables to play with. Who doesn’t love penguins?\n\n\n\nArtwork by allison_horst\n\n\nFirst things first, let us load the penguins dataset.\n\n1# install.packages(\"palmerpenguins\")\n2library(palmerpenguins)\n3data(package = \"palmerpenguins\")\n\n\n1\n\nIf you have not installed the palmerpenguins package, you can install it by uncommenting this line.\n\n2\n\nLoad the palmerpenguins package.\n\n3\n\nLoad the penguins dataset.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Data Structure</span>"
    ]
  },
  {
    "objectID": "03_data_structure.html#take-a-look-at-your-data",
    "href": "03_data_structure.html#take-a-look-at-your-data",
    "title": "3  Basic Data Structure",
    "section": "3.4 Take a Look at your Data",
    "text": "3.4 Take a Look at your Data\nAs a first rule, always, always take a look at your data. The simplest way is simply to print it out:\n\n1penguins\n\n\n1\n\nDisplay the penguins dataset.\n\n\n\n\n\n  \n\n\n\nThis prints about the first couple rows of the dataset (another reason to love tibble over data frame in base R).\nYou may notice some NA values in the dataset. These are missing values, which are common in real-world datasets. We’ll learn how to handle them later.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Data Structure</span>"
    ]
  },
  {
    "objectID": "03_data_structure.html#a-more-structured-view",
    "href": "03_data_structure.html#a-more-structured-view",
    "title": "3  Basic Data Structure",
    "section": "3.5 A more structured view",
    "text": "3.5 A more structured view\nIf you’d like a better view of your dataset, try the skim() function from the skimr package:\n\n1pacman::p_load(skimr)\n2skim(penguins)\n\n\n1\n\nLoad the skimr package.\n\n2\n\nDisplay the summary of the penguins dataset.\n\n\n\n\n\nData summary\n\n\nName\npenguins\n\n\nNumber of rows\n344\n\n\nNumber of columns\n8\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nfactor\n3\n\n\nnumeric\n5\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: factor\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nordered\nn_unique\ntop_counts\n\n\n\n\nspecies\n0\n1.00\nFALSE\n3\nAde: 152, Gen: 124, Chi: 68\n\n\nisland\n0\n1.00\nFALSE\n3\nBis: 168, Dre: 124, Tor: 52\n\n\nsex\n11\n0.97\nFALSE\n2\nmal: 168, fem: 165\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nbill_length_mm\n2\n0.99\n43.92\n5.46\n32.1\n39.23\n44.45\n48.5\n59.6\n▃▇▇▆▁\n\n\nbill_depth_mm\n2\n0.99\n17.15\n1.97\n13.1\n15.60\n17.30\n18.7\n21.5\n▅▅▇▇▂\n\n\nflipper_length_mm\n2\n0.99\n200.92\n14.06\n172.0\n190.00\n197.00\n213.0\n231.0\n▂▇▃▅▂\n\n\nbody_mass_g\n2\n0.99\n4201.75\n801.95\n2700.0\n3550.00\n4050.00\n4750.0\n6300.0\n▃▇▆▃▂\n\n\nyear\n0\n1.00\n2008.03\n0.82\n2007.0\n2007.00\n2008.00\n2009.0\n2009.0\n▇▁▇▁▇\n\n\n\n\n\nThink of skim() as your quick backstage pass, telling you how many rows, columns, missing values, and data types you’re dealing with. Trust me, a few seconds spent peeking at your data can save hours of confusion down the line.\n\nExercise\niris is a widely-used dataset of plant traits. It is a default dataset in R. Take a look at the iris dataset using the skim() function.\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Data Structure</span>"
    ]
  },
  {
    "objectID": "04_ggplot_basic.html",
    "href": "04_ggplot_basic.html",
    "title": "4  Welcome to the World of ggplot2",
    "section": "",
    "text": "4.1 Why so much focus on Graphs?\nAs you can see from the syllabus, we will spend a lot of time on making graphs. Why? Because humans are visual beings. There’s a reason why The New York Times invests in top-tier graphic designers to craft their visuals. A well-designed graph can illuminate complex data in a way that words alone often can’t.\nNow, don’t get me wrong. Graphs aren’t a replacement for text. We still need words to convey intricate ideas and the necessary nuances that come with any scientific discourse. But the sad truth is that most people won’t read your entire paper, they will likely skim it. So if you want your work to resonate, you need to make your key findings as clear as possible. In a world overflowing with information, effective visuals are becoming more and more important.\nThe realm of data visualization has exploded with new tools and frameworks. Among them, ggplot2 stands out. Why focus on ggplot2? Because it encapsulates the right approach to thinking about graphics. Much like learning the grammar of a new language, understanding the “grammar of graphics” will make your visualizations more structured and easier. Additionally, it boasts a large community and a wide array of extension libraries that enable the creation of virtually any plot imaginable.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Welcome to the World of `ggplot2`</span>"
    ]
  },
  {
    "objectID": "04_ggplot_basic.html#why-so-much-focus-on-graphs",
    "href": "04_ggplot_basic.html#why-so-much-focus-on-graphs",
    "title": "4  Welcome to the World of ggplot2",
    "section": "",
    "text": "History of Grammar of Graphics\n\n\n\n\n\nLeland Wilkinson, a statistician, published a book The Grammar of Graphics that laid the foundation for the ggplot2 package. The book introduced a systematic way to think about graphics, breaking them down into components that could be combined in different ways. This approach has since been adopted by many other visualization libraries.\n\n\n\nGrammar of Graphics. From https://www.stat20.org/2-summarizing-data/03-a-grammar-of-graphics/notes",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Welcome to the World of `ggplot2`</span>"
    ]
  },
  {
    "objectID": "04_ggplot_basic.html#crafting-our-first-graph-with-ggplot2",
    "href": "04_ggplot_basic.html#crafting-our-first-graph-with-ggplot2",
    "title": "4  Welcome to the World of ggplot2",
    "section": "4.2 Crafting Our First Graph with ggplot2",
    "text": "4.2 Crafting Our First Graph with ggplot2\nLet us load the penguins dataset from the palmerpenguins package, as we learnt in the previous chapter.\n\npacman::p_load(palmerpenguins) \n\nSuppose we’re curious about the relationship between bill length and bill depth in penguins. In the palmerpenguins dataset, these are represented by bill_length_mm and bill_depth_mm, respectively. Let’s visualize this relationship using ggplot2:\n\n1library(ggplot2)\n2ggplot(\n3  data = penguins,\n4  aes(x = bill_length_mm,\n5      y = bill_depth_mm)\n6) +\n7  geom_point()\n\n\n1\n\nLoad the ggplot2 package.\n\n2\n\nStart a new plot with the function ggplot().\n\n3\n\nSpecify the dataset used in the plot.\n\n4\n\nDefine the x-axis variable as bill_length_mm.\n\n5\n\nDefine the y-axis variable as bill_depth_mm.\n\n6\n\nAdd a layer to the plot.\n\n7\n\nA layer of points to the plot.\n\n\n\n\n\n\n\n\n\n\n\nWhen you run this code, you should see a scatter plot of flipper length against body mass. Congratulations! You’ve just made your first ggplot2 graph.\nLet’s dissect this enchanting code piece by piece:\n\nThe + operator is your magical wand, allowing you to add layers to your plot. Each layer is a graphical element that enhances your masterpiece. Any professional graphical sofware (e.g., Photoshop, Illustrator) works in a similar way.\naes() is used to define the aesthetics of the plot. Here, we map the flipper length to the x-axis and body mass to the y-axis.\ngeom_point() is part of a vast family of geom_* functions that define what you add on top of your graph—points, lines, bars, you name it.\n\nOnce you grasp these concepts, ggplot2 becomes as intuitive as pie (and just as satisfying). When creating scatter plots, you need data, define your axes, and decide what magical elements to add (like points). To abstract it a bit, here’s the fundamental grammar of ggplot2:\n\nggplot(\n1  data = &lt;DATA&gt;,\n2  aes(x = &lt;X&gt;, y = &lt;Y&gt;)\n3) +\n4  &lt;GEOM_FUNCTION&gt;(aes(...))\n\n\n1\n\nSpecify the dataset.\n\n2\n\nDefine the x- and y-axis variable.\n\n3\n\nAdd a layer to the plot.\n\n4\n\nSpecify the type of layer to add.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Welcome to the World of `ggplot2`</span>"
    ]
  },
  {
    "objectID": "04_ggplot_basic.html#tuning-our-plot",
    "href": "04_ggplot_basic.html#tuning-our-plot",
    "title": "4  Welcome to the World of ggplot2",
    "section": "4.3 Tuning our Plot",
    "text": "4.3 Tuning our Plot\nOur plot is functional but not entirely useful. What about different species? To do this, we can use different colors to distinguish them:\n\nggplot(\n  data = penguins,\n  aes(\n    x = bill_length_mm,\n    y = bill_depth_mm\n  )) +\n1  geom_point(aes(color = species))\n\n\n1\n\nWe map the species variable to the color aesthetic.\n\n\n\n\n\n\n\n\n\n\n\nBut why stop at color? Let’s add another layer of distinction by incorporating shapes:\n\nggplot(\n  data = penguins,\n  aes(\n    x = bill_length_mm,\n    y = bill_depth_mm \n  )) +\n1  geom_point(aes(color = species, shape = species))\n\n\n1\n\nDifferentiate the species by both the color and the shape of the points.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Welcome to the World of `ggplot2`</span>"
    ]
  },
  {
    "objectID": "04_ggplot_basic.html#do-not-use-the-default-theme",
    "href": "04_ggplot_basic.html#do-not-use-the-default-theme",
    "title": "4  Welcome to the World of ggplot2",
    "section": "4.4 Do not use the default theme",
    "text": "4.4 Do not use the default theme\nThe default theme is not good. Besides being aesthetically bland, the grey background guzzles a ton of ink when you print. We can change it by adding a theme to the plot. Themes control the non-data elements of your plot—think of them as the outfit your graph wears to impress. Here’s how you can do it:\n\nggplot(\n  data = penguins,\n  aes(\n    x = bill_length_mm,\n    y = bill_depth_mm \n  )) +\n  geom_point(aes(color = species, shape = species)) +\n1  theme_bw()\n\n\n1\n\nApply the theme_bw() theme to the plot.\n\n\n\n\n\n\n\n\n\n\n\nThe theme_bw() is a great starting point—it removes the background gridlines and opts for a clean white backdrop, making your plot easier on the eyes and more printer-friendly. ggplot2 comes with a plethora of themes (check them out here). We’ll dive deeper into theme_*() functions in future classes, but for now, remember that you can transform your plot’s appearance by simply adding a theme_*() function.\nPersonally, I rarely stick to themes provided in the ggplot2 library. I prefer the flair of themes from other packages. My personal favorite? theme_nice() from the jtools package:\n\n1# install.packages(\"jtools\")\nggplot(\n  data = penguins,\n  aes(\n    x = bill_length_mm,\n    y = bill_depth_mm,\n    color = species,\n    shape = species\n  )) +\n  geom_point() +\n2  jtools::theme_nice()\n\n\n1\n\nInstall the jtools package if you haven’t already.\n\n2\n\nApply the theme_nice() from the package jtools theme to the plot.\n\n\n\n\n\n\n\n\n\n\n\n\nOf course, this isn’t yet a publication-ready figure, but it’s a fantastic start. We’ll explore more customization options in future classes.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Welcome to the World of `ggplot2`</span>"
    ]
  },
  {
    "objectID": "04_ggplot_basic.html#exercise",
    "href": "04_ggplot_basic.html#exercise",
    "title": "4  Welcome to the World of ggplot2",
    "section": "Exercise",
    "text": "Exercise\n\nTry to plot the relationship between Body mass (body_mass_g) and Bill depth (bill_depth_mm) for the penguins dataset. Use the species variable to color the points.\n\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nExplore themes. Try to change the theme of the plot to theme_minimal() or theme_classic(). What do you observe?\n\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Welcome to the World of `ggplot2`</span>"
    ]
  },
  {
    "objectID": "05_ggplot_organization.html",
    "href": "05_ggplot_organization.html",
    "title": "5  A Detailed Look at Grammar of Graphics",
    "section": "",
    "text": "5.1 Aesthetic Mappings\nMost plotting libraries, let’s be honest, are a bit of a black box. One command, bang, you’ve got a chart. It’s convenient, sure—a quick fix for the data visualization problem. But peek under the hood? Forget about it. And try tweaking things to get exactly what you want? Good luck with that. They’re built for simplicity, which all too often means a crippling lack of flexibility. And let’s face it, when you’re trying to create truly effective visualizations, customization isn’t a luxury—it’s a necessity.\nggplot2 takes a different tack. It’s built on the idea of a “grammar of graphics”—think of it as a set of Lego bricks for data visualization. Simple, modular pieces that, combined thoughtfully, can construct virtually anything you can imagine. This means you’re not trapped by pre-packaged, cookie-cutter solutions. You can actually design your charts, assembling them piece by piece, crafting them to tell precisely the story your data has to tell.\nNow, there’s a trade-off, of course. You do have to invest some time to grasp its (admittedly elegant) design principles. But trust me, the payoff is well worth the effort. Below, I’ll walk you through some of the fundamental ideas that make this approach so powerful.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Detailed Look at Grammar of Graphics</span>"
    ]
  },
  {
    "objectID": "05_ggplot_organization.html#aesthetic-mappings",
    "href": "05_ggplot_organization.html#aesthetic-mappings",
    "title": "5  A Detailed Look at Grammar of Graphics",
    "section": "",
    "text": "5.1.1 What is an Aesthetic?\nIn ggplot2, aesthetics are the magical connections between your data and how it looks on the plot. The aes() function is like the matchmaker that sets up these relationships. It maps variables in your data to visual properties in your plot. Thus, everything inside the aes() function should correspond to a column in your dataset.\nTo see this, let us again consider plotting the body_mass_g against the bill_depth_mm of the penguins dataset. Suppose we want to color all points blue:\n\nUsing Aesthetic Mapping for a Fixed ColorSetting Color Outside aes()\n\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm \n    )\n) +\n1    geom_point(aes(color = \"blue\")) +\n    theme_minimal()\n\n\n1\n\nThe color aesthetic is set to “blue”.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm \n    ) \n) +\n1    geom_point(color = \"blue\") +\n    theme_minimal()\n\n\n1\n\nThe color is not within aes() function.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAs we can see, the second option is correct. Because \"blue\" is not a variable in the penguins dataset, it is not a valid aesthetic mapping. Thus, the correct way to do it is to take the color as a non-aesthetic mapping.\n\n\n5.1.2 What can you map to?\nYou can map many aesthetics in ggplot2. We have already seen that:\n\nx and y for the x- and y-axis\ncolor for the color of the points. This is a big and very important topic. We will discuss it in more detail in the next section.\nshape for the shape of the points. There are 25 different shapes you can choose from (link). I admit that I google them every time I need to use them.\n\nThere are some other common aesthetics you can map to points in ggplot2:\n\nsize for the size of the points\nalpha for the transparency of the points. It ranges from 0 (completely transparent) to 1 (completely opaque)\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(data = penguins, \n    aes(x = bill_length_mm, y = bill_depth_mm)\n) +\n    geom_point(\n        aes(\n1            color = species,\n2            size = body_mass_g\n        ),\n3        alpha = 0.5,\n4        shape = 21,\n5        fill = \"white\"\n    ) +\n    theme_minimal()\n\n\n1\n\nThe species variable is mapped to the color aesthetic. Different species will have different colors.\n\n2\n\nThe body_mass_g variable is mapped to the size aesthetic. Different body masses will have different sizes.\n\n3\n\nThe alpha is the same for all. 0.5 makes the points semi-transparent.\n\n4\n\nThe shape is the same for all. This makes the points filled circles.\n\n5\n\nThe fill is the same for all. This makes the points white.\n\n\n\n\n\n\n\n\n\n\n\nIf you understand the above code, you would have a solid working knowledge of aesthetic mapping in ggplot2:\n\nWe see that two variables are mapped to the color and size aesthetics. This means that different species will have different colors and different body masses will have different sizes. Thus, you can map different variables to different aesthetics. This gives us great flexibility in how we can visualize our data.\nA mapped aesthetic will have a legend by default. This is always needed to interpret the plot. Two different aesthetics will have two different legends.\nBecause alpha, shape, and fill are set outside the aes() function, all points will have the same transparency, shape, and fill.\n\n\n\nExercise\n\nFix the Aesthetic Mapping. Run the following code. Identify the error and correct it.\n\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nalpha is incorrectly placed inside aes() because it is fixed, and size should be inside aes() as body_mass_g is a variable in the data.\n\n\n\n\nCustomize Aesthetics. Adjust the transparency (alpha) based on body_mass_g, change the shape based on island, and set all points to purple.\n\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Detailed Look at Grammar of Graphics</span>"
    ]
  },
  {
    "objectID": "05_ggplot_organization.html#geometric-objects",
    "href": "05_ggplot_organization.html#geometric-objects",
    "title": "5  A Detailed Look at Grammar of Graphics",
    "section": "5.2 Geometric objects",
    "text": "5.2 Geometric objects\nGeometric objects (geoms) are the visual representations of your data. Think of them as the artists painting your data onto the canvas. For example, we have already used geom_point() to create a scatter plot. ggplot2 offers a variety of geoms (geom_*()) to create different types of plots. As an example, we can use a different geometric object for the same data above:\n\ngeom_point()geom_smooth()\n\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm \n    ) \n) +\n1    geom_point() +\n    theme_minimal()\n\n\n1\n\nThe geom_point() function is used to create a scatter plot.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm \n    ) \n) +\n1    geom_smooth() +\n    theme_minimal()\n\n\n1\n\nThe geom_smooth() function is used to create a smooth line that fits the trend of the data.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor the two plots above, left and right have the same data, same axis, but different geometric objects. The left plot uses geom_point() to create a scatter plot, while the right plot uses geom_smooth() to create a smooth line that fits the trend of the data.\nYou can use more than one geometric object in a plot. For example, you can add a smooth line and points on the plot. Notice that the orders of adding layers matter. The last layer will be on top of the previous layers. To see this,\n\ngeom_point() then geom_smooth()geom_smooth() then geom_point()\n\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm \n    ) \n) +\n1    geom_point() +\n2    geom_smooth() +\n    theme_minimal()\n\n\n1\n\nThe geom_point() function is used to create a scatter plot.\n\n2\n\nThe geom_smooth() function is used to create a smooth line that fits the trend of the data.\n\n\n\n\n\n\n\n\n\n\n\nThe smmoth line is on top of the points.\n\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm \n    ) \n) +\n1    geom_smooth() +\n2    geom_point() +\n    theme_minimal()\n\n\n1\n\nFirst we create a smooth line that fits the trend of the data.\n\n2\n\nThen we add points to the plot.\n\n\n\n\n\n\n\n\n\n\n\nNow the black points are on top of the smooth line.\n\n\n\n\nExercise\nWe want to explore the relationship between body_mass_g and flipper_length_mm. Please plot the data with both the points and a smooth trend line. What preliminary conclusions can you draw from the plot?\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Detailed Look at Grammar of Graphics</span>"
    ]
  },
  {
    "objectID": "05_ggplot_organization.html#organizational-structure",
    "href": "05_ggplot_organization.html#organizational-structure",
    "title": "5  A Detailed Look at Grammar of Graphics",
    "section": "5.3 Organizational structure",
    "text": "5.3 Organizational structure\nThis is not something typiucally taught in length in the typical ggplot2 tutorial. I kindly learnt it from experience, through many scratching many heads with mysterious codes.\n\n5.3.1 Global vs Local Aesthetic Mapping\nTo show this, we introduce another aesthetic mapping: group. It is a central aes that is used to group data. For example, in the figure above, it is quite annoying that the smooth line desciebes the average trend across species, but we are often only intrested within species. We can group the data by species so that the smooth line is fitted to each species separately.\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    ) \n) +\n    geom_point() + \n1    geom_smooth(aes(group = species)) +\n    theme_minimal()\n\n\n1\n\nThe species variable is mapped to the group aesthetic. This means that the smooth line will be fitted to each species separately.\n\n\n\n\n\n\n\n\n\n\n\nBut the figure itself is still not very informative as it is diffcult to tell which species is which. We can add a color aesthetic\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    ) \n) +\n    geom_point(aes(color = species)) + \n    geom_smooth(aes(group = species)) + \n    theme_minimal()\n\n\n\n\n\n\n\n\nHowever, it is annoying that the color only applies to the points, but not the smooth line. There are two ways to fix this.\n\nMapping species to color separatelyMapping species to color together\n\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    ) \n) +\n1    geom_point(aes(color = species)) +\n2    geom_smooth(aes(group = species, color = species)) +\n    theme_minimal()\n\n\n1\n\nThe species variable is mapped to the color aesthetic for the points.\n\n2\n\nThe species variable is mapped to the color aesthetic for the smooth line.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm,\n1        group = species,\n        color = species\n    ) \n) +\n    geom_point() + \n    geom_smooth() +  \n    theme_minimal()\n\n\n1\n\nThe species variable is mapped to the color aesthetic in the beginning but not in the geom_point() or geom_smooth() functions.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThese two approaches produce the same results! In brief, what is included within the ggplot() function is applied to all geometric objects, while what is included within the geom_*() functions is only applied to that specific geometric object. A best practice is, whenver you are unsure, to include the aesthetic mapping in the geom_*() function.\n\n\n\n\n\n\nA cumbersome way (NOT RECOMMENDED)\n\n\n\n\n\nTo help you better understand, we can write quite cumbersome codes to achieve the same results :\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins\n) +\n    geom_point(\n        aes(\n            x = bill_length_mm,\n            y = bill_depth_mm,\n            group = species,\n            color = species\n        )\n    ) +\n    geom_smooth(\n        aes(\n            x = bill_length_mm,\n            y = bill_depth_mm,\n            group = species,\n            color = species\n        )\n    ) +\n    theme_minimal()\n\n\n\n\n\n\n\n\nAs we can see, even for x and y, they do not have to be included in the ggplot() function. They can be included in the geom_*() functions.\n\n\n\n\n\nExercise\nThis exercise aims to show you a common pitall in using ggplot2 with global vs local assignment.\n\nWe want is to plot a smooth lines grouped by island, and the points are colored by species. Run the following code and see what are the warnings.\n\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nIssue: The smooth is working on species level, not on island level.\nCuause: geom_smooth took the color aesthetic from the global aes() function, and this messes up the local group aes, because color is inherentely a grouping aes.\nCaution: While ggplot2 works this time, this is a common pitfall that can lead to unexpected results with more complex figures.\n\n\n\n\n\nSolve the issue above.\n\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n  data = penguins,\n  aes(\n    x = bill_length_mm,\n    y = bill_depth_mm\n  )\n) +\n  geom_point(aes(color = species)) +\n  geom_smooth(aes(group = island)) +\n  theme_minimal()\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_smooth()`).\n\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n5.3.2 Global vs Local Data\nThis is slightly more advanced, but it is good to know that the data = * argument can be set globally or locally. For example, I want to have the points for all species, but only the trend line for the Gentoo species.\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    ) \n) +\n    geom_point(aes(color = species)) + \n    geom_smooth(data = filter(penguins, species == \"Gentoo\")) + \n    theme_minimal()\n\n\n\n\n\n\n\n\nWe will explain what the filter() function does when we go to data wrangling. For now, just know that it is used to get the subset of data on species .",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Detailed Look at Grammar of Graphics</span>"
    ]
  },
  {
    "objectID": "06_good_plots.html",
    "href": "06_good_plots.html",
    "title": "6  First Publication-Ready Figure",
    "section": "",
    "text": "6.1 Choose a Good Theme\nWhile many ggplot2 tutorials dive headfirst into creating various plot types (e.g., bar plots, line plots – the usual suspects). We’ll get to those, but first, let’s talk about what truly sets ggplot2 apart: its powerful customization. Although other plotting libraries might offer seemingly magical one-line solutions, these rarely survive contact with the harsh realities of academic publication and presentation. Effective visualizations require careful customization to address specific research questions. This guide covers key steps to create self-contained, informative, and aesthetically pleasing graphics—graphics that will make your readers (and reviewers) happy.\nFirst, let’s rewind to where we left off in the previous chapter:\nRemember, themes control the non-data elements of your plot. In the ggplot2 universe, the theme_*() functions offer opinionated customization options to tweak your plot’s appearance. Picking a theme you like can save you a boatload of time. Here are some choices I like:\nThere are many other themes out there, so feel free to explore and find one that suits your style.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>First Publication-Ready Figure</span>"
    ]
  },
  {
    "objectID": "06_good_plots.html#choose-a-good-theme",
    "href": "06_good_plots.html#choose-a-good-theme",
    "title": "6  First Publication-Ready Figure",
    "section": "",
    "text": "Using jtoolsUsing ggthemrUsing hrbrthemes\n\n\nI have a soft spot for theme_nice() from the jtools package. It’s clean, minimalistic, and easy on the eyes.\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    )\n) +\n  geom_point(aes(color = species)) +\n1  jtools::theme_nice()\n\n\n1\n\nWe use the theme_nice() function from the jtools package to apply the nice theme to the plot. If you have not installed jtools package yet, just run install.packages(\"jtools\").\n\n\n\n\n\n\n\n\n\n\n\n\n\nggthemr offers a delightful collection of themes for ggplot2. It’s not on CRAN, so you’ll need to install it from GitHub.\n\npacman::p_load(devtools)\ninstall_github('Mikata-Project/ggthemr')\n\nHere’s how to use the fresh theme in it, one of my favorites.\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\n\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    )\n) +\n  geom_point(aes(color = species)) +\n  ggthemr::ggthemr('fresh', set_theme = FALSE)$theme\n\n\n\n\n\n\n\n\nFor more options, check out its GitHub page\n\n\nAnother contender is hrbrthemes, which also offers a suite of ggplot2 themes. I’m not its biggest fan, but it is quite popular.\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\n\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    )\n) +\n  geom_point(aes(color = species)) +\n  hrbrthemes::theme_ipsum()\n\n\n\n\n\n\n\n\nFor those who prefer dark background, hrbrthemes has you covered:\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    )\n) +\n  geom_point(aes(color = species)) +\n  hrbrthemes::theme_modern_rc()\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\niris is a widely known dataset introduced by Ronald Fisher. It contains three plant species and four features measured for each sample. We will use this dataset to explore the association between Sepal.Width and Petal.Width as exercise throughout this Chapter. Try three different themes on the iris dataset:\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nAs one example, you can use jtools::theme_nice() as the theme.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>First Publication-Ready Figure</span>"
    ]
  },
  {
    "objectID": "06_good_plots.html#customizing-the-geometry",
    "href": "06_good_plots.html#customizing-the-geometry",
    "title": "6  First Publication-Ready Figure",
    "section": "6.2 Customizing the Geometry",
    "text": "6.2 Customizing the Geometry\n\nSeparate the Points by SpeciesDon’t Settle for Default Point ShapesAssign Unique ShapesChange the Color/Fill Palette\n\n\nA common issue with scatter plots is that the boundary of points are unclear among different groups. We will use a new geometric object to lay the boundary of the points clear. We will use the package ggforce to add an ellipse around the points. As usually, if you have not installed the package yet, just run install.packages(\"ggforce\").\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    )\n) +\n1  ggforce::geom_mark_ellipse(\n2    aes(fill = species),\n3    alpha = 0.05,\n4    color = 'transparent'\n  ) +\n  geom_point(aes(color = species)) +\n  jtools::theme_nice()\n\n\n1\n\nWe use the geom_mark_ellipse() function from the ggforce package to add an ellipse around the points.\n\n2\n\nWe fill the ellipse differently by species using the fill = species argument.\n\n3\n\nWe make the ellipse more transparent as we don’t want it to be too distracting.\n\n4\n\nWe make the border of the ellipse transparent using the color = 'transparent' argument.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing a Density Geometry\n\n\n\n\n\nggforce::geom_mark_ellipse() is a great way to show the distribution of points. However, it may not be the best choice for large datasets, especially when we want to show the density of points.\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\n\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    )\n) +\n1  ggdensity::geom_hdr(aes(fill = species)) +\n2  # geom_point(shape = 21) +\n  jtools::theme_nice()\n\n\n1\n\nWe use the geom_hdr() function from the ggdensity package to create a density plot. The fill = species argument specifies that we want to fill the density plot with the color of the species.\n\n2\n\nWe use the geom_point() function to add points to the density plot. The shape = 21 argument specifies that we want to use point shape 21, which is a circle with a border.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe default points are aesthetically not pleasing, at least to me. Customizing them can make your plot visually appealing. A common trick is to use point shape 21—a circle with a border. Fill the circle with the species color, add some transparency, and give it a white border. This way, overlapping points don’t turn into an unrecognizable blob.\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    )\n) +\n  ggforce::geom_mark_ellipse(\n    aes(fill = species),\n    alpha = 0.05, \n    color = 'transparent' \n  ) +\n  geom_point(\n1    aes(fill = species),\n2    color = \"white\",\n3    shape = 21,\n4    alpha = .6,\n5    size = 3\n  ) +\n  jtools::theme_nice()\n\n\n1\n\nWe fill the points with the color of the species using the fill = species argument.\n\n2\n\nWe make the border of the points white using the color = \"white\" argument.\n\n3\n\nWe use point shape 21, which is a circle with a border, using the shape = 21 argument.\n\n4\n\nWe make the points slightly transparent using the alpha = .6 argument.\n\n5\n\nWe increase the size of the points using the size = 3 argument.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA Fancy Trick (Just in Case)\n\n\n\n\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    )\n) +\n  geom_point(\n    aes(\n      fill = species, \n      size = body_mass_g\n    ), \n    shape = 21,\n    color = \"transparent\",\n    alpha = .3\n  ) +\n  geom_point(\n    aes(\n      size = body_mass_g\n    ), \n    shape = 21,\n    color = \"white\",\n    fill = \"transparent\"\n  ) +\n  jtools::theme_nice()\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe’ve got points colored by species. However, when people print it out in black and white, they may not be able to distinguish the points. Let’s assign different shapes to each species for better clarity. To be concistent, we use other hollow shapes for points.\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    )\n) +\n  ggforce::geom_mark_ellipse(\n    aes(fill = species),\n    alpha = 0.05,\n    color = 'transparent' \n  ) +\n  geom_point(\n    aes(\n      shape = species,\n1      fill = species\n    ), \n    color = \"white\",\n    size = 3,\n    alpha = .6\n  ) +\n2  scale_shape_manual(values = c(21, 22, 23)) +\n  jtools::theme_nice()\n\n\n1\n\nWe fill the points with the color of the species using the fill = species argument.\n\n2\n\nWe use different shapes for each species using the scale_shape_manual(values = c(21, 22, 23)) argument. Nobody can remeber the meanings of these numbers, so just google when you need to.\n\n\n\n\n\n\n\n\n\n\n\nNow, points are distinguishable by both color and shape. Voilà!\n\n\nIf you are unhappy with the default color palette, you can change it. Here, we use the scale_fill_manual() function to specify the fill color of each species:\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\np &lt;- ggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    )\n) +\n  ggforce::geom_mark_ellipse(\n    aes(fill = species),\n    alpha = 0.05,\n    color = 'transparent' \n  ) +\n  geom_point(\n    aes(\n      shape = species,\n      fill = species \n    ), \n    color = \"white\",\n    size = 3,\n    alpha = .6\n  ) +\n  scale_shape_manual(values = c(21, 22, 23)) + \n1  scale_fill_manual(\n    values = c(\n2      \"Adelie\" = \"#00AFBB\",\n3      \"Chinstrap\" = \"#E7B800\",\n4      \"Gentoo\" = \"#FC4E07\"\n    ) \n  ) +\n  jtools::theme_nice()\n\np\n\n\n1\n\nWe change the fill of the points using the scale_fill_manual() function.\n\n2\n\nWe specify the fill of the Adelie species using the Adelie = \"#00AFBB\" argument.\n\n3\n\nWe specify the fill of the Chinstrap species using the Chinstrap = \"#E7B800\" argument.\n\n4\n\nWe specify the fill of the Gentoo species using the Gentoo = \"#FC4E07\" argument.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA Short Cut (Not Recommended)\n\n\n\n\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\n\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    )\n) +\n  geom_point(\n    aes(fill = species),\n    color = \"white\", \n    shape = 21, \n    alpha = .6, \n    size = 3 \n  ) +\n  scale_fill_manual(\n    values = c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\")\n  ) +\n  jtools::theme_nice()\n\n\n\n\n\n\n\n\nWhile we have saved a few lines of code, it is not recommended. It is better to use the specific names as keys, so that you can be absolutely sure what color is assigned to which species.\n\n\n\nChoose colors wisely. Everyone has their own preferences, but there are some guidelines for best practice. We will get back to this topic later. But for now, I recommend some fun and artsy palettes:\n\nWes Anderson\nMoMA\nMetBrewer\nPNWColors\n\nAnd if you are adventurous, almost all palettes are accessible from the paletteer package (link).\n\n\n\n\nExercise\nLet us apply what we have learnt so far. Below is a simple scatter plot of the iris dataset. Your task is to customize the plot with:\n\ncustomized point shape for each species\nuse a non-default color.\nadd point cloud boundary for each species (try ggforce::geom_mark_ellipse(), ggforce::geom_mark_hull() and ggforce::geom_mark_rect())\n\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nlibrary(ggplot2)\n\nggplot(\n    data = iris,\n    aes(\n        x = Sepal.Width,\n        y = Petal.Width\n    )\n) +\n  ggforce::geom_mark_rect(\n    aes(fill = Species),\n    alpha = 0.05,\n    color = 'transparent' \n  ) +\n  geom_point(\n      aes(\n          shape = Species,\n          fill = Species\n      ),\n      color = \"white\",\n      size = 3,\n      alpha = .6\n  ) +\n  scale_shape_manual(values = c(21, 22, 23)) +\n  scale_fill_manual(\n    values = MetBrewer::met.brewer(name=\"Demuth\", n=3, type=\"discrete\") \n  ) +\n  theme_minimal()",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>First Publication-Ready Figure</span>"
    ]
  },
  {
    "objectID": "06_good_plots.html#make-the-plot-more-self-contained",
    "href": "06_good_plots.html#make-the-plot-more-self-contained",
    "title": "6  First Publication-Ready Figure",
    "section": "6.3 Make the Plot More Self-Contained",
    "text": "6.3 Make the Plot More Self-Contained\nThe rule of thumb is to make your plot as self-contained as possible. Ideally, the reader should be able to understand the plot without referring to the text. There are many steps to achieve this, but we will focus on the most important ones for now.\n\nAdd LabelsAdd a TitleAdd a trend line\n\n\nClarity starts with clear labels. Use the labs() function to name your axes.\n\np + \n  labs( \n1    x = \"Bill Length (mm)\",\n2    y = \"Bill Depth (mm)\"\n  )\n\n\n1\n\nWe add a label to the x-axis using the x = \"label text\" argument.\n\n2\n\nWe add a label to the y-axis using the y = \"label text\" argument.\n\n\n\n\n\n\n\n\n\n\n\nWe will get back to labelling later (with the library ggtext and ggrepel), but for now, let’s keep it simple.\nNotice how we add the layer directly to the plot p from the previous figure. This is a common (and very powerful) trick in ggplot2.\n\n\nSecond, what’s this plot telling us? A title can make that clear, also using labs():\n\np + \n  labs(\n    x = \"Bill Length (mm)\",\n    y = \"Bill Depth (mm)\",\n1    title = \"Bill Length and Depth of Penguins are Positively Correlated\"\n  )\n\n\n1\n\nWe add a title to the plot using the title = \"title text\" argument.\n\n\n\n\n\n\n\n\n\n\n\nNow, your plot clearly communicates its main message.\n\n\nHelp your readers spot trends by adding a trend line. Remember, the goal is to make the plot as easy to understand as possible.\n\np1 &lt;- p + \n  labs(\n    x = \"Bill Length (mm)\",\n    y = \"Bill Depth (mm)\",\n    title = \"Bill Length and Depth are Positively Correlated\"\n  ) +\n  geom_smooth(\n1    aes(group = species, color = species),\n2    method = \"lm\", se = FALSE\n  ) +\n3  scale_color_manual(\n    values = c(\n      \"Adelie\" = \"#00AFBB\",  \n      \"Chinstrap\" = \"#E7B800\", \n      \"Gentoo\" = \"#FC4E07\" \n    ) \n  )\n\np1\n\n\n1\n\nWe add a linear trend line to the plot using the geom_smooth() function. The group = species argument specifies that we want to fit a separate trend line for each species.\n\n2\n\nWe add a linear trend line to the plot using the geom_smooth() function. The method = \"lm\" argument specifies that we want to fit a linear model to the data. The se = FALSE argument specifies that we do not want to display the standard error around the trend line.\n\n3\n\nWe need to change the color of the trend line using the scale_color_manual() function.\n\n\n\n\n\n\n\n\n\n\n\nNote: color and fill are different aesthetics in ggplot2, so you need to set them separately. The grammar for setting them is the same.\n\n\n\n\nExercise\nLet us apply what we have learnt so far. Below is a simple scatter plot of the iris dataset. Your task is to customize the plot with customized point shape for each species and use a non-default color.\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nlibrary(ggplot2)\nlibrary(MetBrewer)\n\np_exe &lt;- ggplot(\n    data = iris,\n    aes(\n        x = Sepal.Width,\n        y = Petal.Width\n    )\n) +\n  geom_point(\n      aes(\n          shape = Species,\n          fill = Species\n      ),\n      color = \"white\",\n      size = 3,\n      alpha = .6\n  ) +\n  scale_shape_manual(values = c(21, 22, 23)) +\n  scale_fill_manual(\n    values = MetBrewer::met.brewer(name=\"Demuth\", n=3, type=\"discrete\") \n  ) +\n  theme_minimal()\n\np_exe +\n  labs(\n      x = \"Petal width (cm)\",\n      y = \"Sepal width (cm)\",\n      title = \"Association between Sepal and Petal Width\"\n  ) +\n  geom_smooth(\n      aes(group = Species, color = Species),\n      method = \"lm\", se = FALSE\n  ) +\n  scale_color_manual(\n    values = MetBrewer::met.brewer(name=\"Demuth\", n=3, type=\"discrete\") \n  )\n\n`geom_smooth()` using formula = 'y ~ x'",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>First Publication-Ready Figure</span>"
    ]
  },
  {
    "objectID": "06_good_plots.html#dealing-with-legend",
    "href": "06_good_plots.html#dealing-with-legend",
    "title": "6  First Publication-Ready Figure",
    "section": "6.4 Dealing with legend",
    "text": "6.4 Dealing with legend\nBy default, the legend hangs out on the right. Often, placing it on top (or bottom) or inside the figure makes for a cleaner look. Let’s see how.\n\nInside the PlotOn Top or Bottom\n\n\n\np1 +\n  theme(\n1    legend.position = c(0.12, 0.1)\n  )\n\n\n1\n\nWe place the legend inside the plot using the legend.position = c(*, *) argument.\n\n\n\n\n\n\n\n\n\n\n\nThe first number is the x-coordinate, and the second is the y-coordinate, both ranging from 0 (left/bottom) to 1 (right/top).\n\n\n\np1 +\n  theme(\n1    legend.position = \"top\"\n2    # legend.position = \"bottom\"\n  )\n\n\n1\n\nWe place the legend on the top using the legend.position = \"top\" argument.\n\n2\n\nWe can place the legend on the bottom using the legend.position = \"bottom\" argument.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnother common blunder: not paying attention to the legend title.\n\nRemove the legend titleRewrite the legend title\n\n\nSometimes, for example with expert audiences, the legend title is redundant. Remove it with theme()\n\np2 &lt;- p1 +\n  theme(\n    legend.position = c(0.12, 0.1),\n1    legend.title = element_blank()\n  )\n\np2\n\n\n1\n\nWe remove the legend title using the legend.title = element_blank() argument.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor a more informative, self-contained figure, you might need to rewrite the legend title. Since ggplot2 can merge multiple legends (color, shape, linetype), ensure consistency by renaming all relevant legends.\n\np1 +\n  theme(\n    legend.position = \"top\"\n  ) +\n  labs(\n1    color = \"Penguin species\",\n    shape = \"Penguin species\",\n    fill = \"Penguin species\",  # &lt;3&gt;,\n    linetype = \"Penguin species\"\n  )\n\n\n1\n\nWe rewrite the title of the color legend using the labs(color = \"label text\") argument.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnother approach is to design the figure so that the legend is not necessary. They are usually more complicated and labor-heavy, but definitely worth it. Below we show two approaches:\n\nFacet the PlotText AnnotationSubtitle\n\n\n\np1 +\n  facet_wrap(~species) +\n  theme(\n    legend.position = \"none\"\n  )\n\n\n\n\n\n\n\n\n\n\n\np1 +\n    theme(legend.position = \"none\") +\n1    annotate(\"text\",\n2        x = 33, y = 14,\n3        label = \"Adelie\",\n4        color = \"#00AFBB\", size = 5\n    ) + \n    annotate(\"text\",\n        x = 55, y = 22,\n        label = \"Chinstrap\", color = \"#E7B800\", size = 5\n    ) +\n    annotate(\"text\",\n        x = 58, y = 14,\n        label = \"Gentoo\", color = \"#FC4E07\", size = 5\n    )\n\n\n1\n\nWe add text annotations to the plot using the annotate() function.\n\n2\n\nWe specify the x and y coordinates of the text annotations using the x = , y = arguments.\n\n3\n\nWe specify the label of the text annotations using the label = \"label text\" argument.\n\n4\n\nWe specify the color of the text annotations using the color = argument. We increase the size of the text annotations using the size = argument.\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can use subtitle as an effective way to label the groups. We can use the ggtext package to add the subtitle. If you have not installed the package yet, just run install.packages(\"ggtext\").\n\nlibrary(ggtext)\np1 +\n  theme(\n    legend.position = \"none\"\n  ) +\n  labs(\n    subtitle = \"Penguin Species: \n    &lt;span style = 'color:#00AFBB;'&gt;**Adelie**&lt;/span&gt;&lt;span style = 'color:#00AFBB;font-size:22pt'&gt;\\u25CF&lt;/span&gt;,\n    &lt;span style = 'color:#E7B800;'&gt;**Chinstrap**&lt;/span&gt;&lt;span style = 'color:#E7B800;font-size:20pt'&gt;\\u25A0&lt;/span&gt;,\n    &lt;span style = 'color:#FC4E07;'&gt;**Gentoo**&lt;/span&gt;&lt;span style = 'color:#FC4E07;font-size:22pt'&gt;\\u2666&lt;/span&gt;\"\n  ) +\n  theme(\n    plot.title = element_text(hjust = 0.5),\n    plot.subtitle = element_textbox_simple(halign = 0, size = 12)\n  )\n\n\n\n\n\n\n\n\nThere is also another package marquee that makes this process easier. But it is still under active development. Check the documentation if you are intrested.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>First Publication-Ready Figure</span>"
    ]
  },
  {
    "objectID": "06_good_plots.html#use-larger-annotations",
    "href": "06_good_plots.html#use-larger-annotations",
    "title": "6  First Publication-Ready Figure",
    "section": "6.5 Use larger annotations",
    "text": "6.5 Use larger annotations\nWhenever I read papers or listen to talks, I often see that the font size is too small. The following is a quote from the book Fundamentals of Data Visualization by Claus Wilke:\n\nIf you take away only one single lesson from this book, make it this one: Pay attention to your axis labels, axis tick labels, and other assorted plot annotations. Chances are they are too small. In my experience, nearly all plot libraries and graphing softwares have poor defaults. If you use the default values, you’re almost certainly making a poor choice.\n\nWe can increase the font size of the axis labels using the theme() function.\n\np3 &lt;- p2 +\n1  theme(\n2    axis.text = element_text(size = 12),\n3    axis.title = element_text(size = 14),\n4    plot.title = element_text(size = 16),\n5    legend.text = element_text(size = 12)\n  )\np3\n\n\n1\n\nWe increase the font size of the axis labels using the theme() function.\n\n2\n\nWe increase the font size of the axis labels using the axis.text = element_text(size = ) argument.\n\n3\n\nWe increase the font size of the axis labels using the axis.title = element_text(size = ) argument.\n\n4\n\nWe increase the font size of the title using the title = element_text(size = ) argument.\n\n5\n\nWe increase the font size of the legend text using the legend.text = element_text(size = ) argument.\n\n\n\n\n\n\n\n\n\n\n\nSelecting the appropriate font size in ggplot2 is somewhat of an art. A common mistake is using a font size that looks great in the RStudio preview but doesn’t scale appropriately when exporting the plot to different sizes. While the plot elements typically adjust to the export dimensions, fixed font sizes do not, leading to readability issues and challenges with reproducibility. To address this,\n\nYou can finalize all other aspects of the plot first and then adjust the font sizes to ensure they are readable and harmonize with the overall visualization.\nAlternaticely, you can use a fixed canvas size for the plot, which can help you better control the font sizes:\n\n\np2 + \n  patchwork::plot_layout(widths = 50, heights = 50) +\n  theme(...)",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>First Publication-Ready Figure</span>"
    ]
  },
  {
    "objectID": "06_good_plots.html#the-full-code",
    "href": "06_good_plots.html#the-full-code",
    "title": "6  First Publication-Ready Figure",
    "section": "6.6 The full code",
    "text": "6.6 The full code\nAlright, brace yourself. The full code for our pièce de résistance—our final figure—is right below. Run it with a single click and marvel as the figure above magically appears:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nYes, the code might look like it’s speaking in tongues, but fear not! It’s all about the logic. Let’s break down the wizardry step by step:\n\nWe always start with ggplot() function. This is your canvas. Specify your data and map out the x and y axes.\nThe first couple of layers are adding the geometries (geom_*). What to add are motivated by what we want to show. Since we’re exploring the relationship between bill length and bill depth, we need:\n\nPoints (geom_point): Each penguin observation.\nTrend Lines (geom_smooth): To highlight that positive relationship.\nEllipses (ggforce::geom_mark_ellipse): To neatly separate different species.\nPro Tip: The order matters! The first layer (ellipses) sits at the bottom, with points and trend lines layering on top. Carefully think about the order of layers.\n\nWe then customize so that the aesmatics match your vision. This is controlled by the scale_* function. In this plot, the customized aes includes shape, color, and fill.\nLabeling with labs(): Clear labels make your plot understandable at a glance.\nWe then customize the theme, the non-data elements of the plot:\n\nWe first use a good theme. This saves us a lot of time in custimization.\nWe then do our own custimization. This is controlled by the theme() function. We can change the font size, the position of the legend, etc.\n\n\nThe logic behind every ggplot2 figure follows these structured steps. It may seem intimidating at first, but I promise you will get used to it and even fall in love with it:\n\nEncourages Thoughtful Design: ggplot2 challenges you to think deeply about what you want to visualize. This thoughtful approach not only creates stunning visuals but also helps you understand your data on a deeper level. I have benefitted many times from this.\nA Playground for Creativity: The beauty of ggplot2 lies in its flexibility. As I said multiple times, you are in full control of your plot. Add or remove layers effortlessly and experiment with countless extensions to find what best communicates your data. Who says you cannot do experiments on computer!",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>First Publication-Ready Figure</span>"
    ]
  },
  {
    "objectID": "06_good_plots.html#exporting-your-plot-with-precision",
    "href": "06_good_plots.html#exporting-your-plot-with-precision",
    "title": "6  First Publication-Ready Figure",
    "section": "6.7 Exporting Your Plot with Precision",
    "text": "6.7 Exporting Your Plot with Precision\nFinally, we need to export the plot such as pdf or png, so we can use it elsewhere (like submit to a journal). However, a minimalist approach like ggsave(\"plot_name.pdf\") lacks the precision needed for publication-quality figures. Below, we show the best practices for exporting your plot:\n\nSave as PDFSave as PNG\n\n\nPDFs are the gold standard for vector graphics in academic publications due to their scalability and clarity. To save your plot as a PDF, consider the following comprehensive method:\n\nggsave(\n1  filename = \"plot.pdf\",\n2  plot = p3,\n3  width = 8,\n4  height = 6,\n5  units = \"in\",\n  device = cairo_pdf\n)\n\n\n1\n\nFilename Specification: Clearly define the output file name and its format using the filename argument. This ensures your plot is saved with the desired name and extension.\n\n2\n\nPlot Selection: The plot argument allows you to specify which ggplot object you intend to save. This is particularly useful when working with multiple plots.\n\n3\n\nDimensional Control: By setting the width and height, you control the physical size of the plot, ensuring it fits seamlessly within your manuscript’s layout.\n\n4\n\nUnit Definition: Specifying units (inches, centimeters, etc.) provides consistency, especially when adhering to journal-specific formatting guidelines.\n\n5\n\nDevice Choice: The cairo_pdf device offers superior rendering quality, handling fonts and graphical elements with precision.\n\n\n\n\nWhy do we bother to specify plot dimensions? For one thing, RStudio window sizes can vary from one computer to another, which may cause your figures to appear distorted or improperly sized if dimensions aren’t fixed. Additionally, font sizes in plots are fixed and do not automatically scale with plot dimensions, leading to text that may be too large or too small relative to the plot size. I’ve had nightmares to reproduce well-formatted figures because I forgot to set these dimensions. To avoid such headaches, it’s best practice to always specify the width and height when exporting your plots.\n\n\nWhile PDFs are ideal for vector graphics, many journals only accept non-vector format like PNGs. To achieve optimal quality and avoid common pitfalls related to fonts and rendering, the ragg package is highly recommended. If you haven’t installed it yet, simply execute install.packages(“ragg”).\n\nggsave(\n1  filename = \"plot.png\",\n  plot = p3, \n  width = 8, \n  height = 6, \n  units = \"in\", \n2  device = ragg::agg_png\n)\n\n\n1\n\nFilename Specification: Clearly define the output file name and its format using the filename argument.\n\n2\n\nDevice Choice: Utilizing ragg::agg_png ensures that the PNG is rendered with high fidelity, handling intricate details and text smoothly.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>First Publication-Ready Figure</span>"
    ]
  },
  {
    "objectID": "06_good_plots.html#refining-your-plot-beyond-r",
    "href": "06_good_plots.html#refining-your-plot-beyond-r",
    "title": "6  First Publication-Ready Figure",
    "section": "6.8 Refining Your Plot Beyond R",
    "text": "6.8 Refining Your Plot Beyond R\nWhile ggplot2 is powerful, it is not a design software and it can be paiful to do everything in R. To add extra touch, you can save it as a vector graphic (e.g., pdf) and edit it in a design software like Adobe Illustrator or Inkscape.\nHowever, learning a new software can be time-consuming. Luckily, you get to do many of these tasks in PowerPoint. The trick is to save the plot as svg format. This is a vector graphic format that can be easily imported into editable format in PowerPoint. Another practicle trick is to remove the white background of the plot. Below is the code to do this:\n\np_svg &lt;- p3 + \n  theme(\n1    panel.background = element_rect(fill = \"transparent\", colour = NA_character_),\n2    plot.background = element_rect(fill = \"transparent\", colour = NA_character_),\n3    legend.background = element_rect(fill = \"transparent\"),\n4    legend.box.background = element_rect(fill = \"transparent\"),\n5    legend.key = element_rect(fill = \"transparent\")\n  )\n\nggsave(\n  filename = \"plot.svg\", \n  plot = p_svg, \n  width = 8, \n  height = 6, \n  units = \"in\"\n)\n\n\n1\n\nWe make the panel background transparent.\n\n2\n\nWe make the plot background transparent.\n\n3\n\nWe make the legend background transparent.\n\n4\n\nWe make the legend box background transparent.\n\n5\n\nWe make the legend key transparent.\n\n\n\n\nWith the exported svg in Keynote, you can easily add annotations, arrows, and other design elements to make your plot more informative and appealing. As an example, below adds the artistic plot of penguins to better illustate the two axis:\n\n\n\nHooray! Our First Publication-Ready Figure\n\n\n\n\n\n\n\n\nWhere to find artistic illustrations\n\n\n\nA well-drawn illustration can make your plot more engaging. It is not easy, as this is not a standardized process. That said, here are some solid options for finding awesome illustrations:\n\nHire an artist. Honestly, this is your best bet for top-notch quality and tons of customization. Plus, you’re supporting creative folks! Here are a few options to check out (not sponsored—just examples):\n\nLife Science Studios\nSayoStudio\nArtSciStudio\n\nUse online resources. If hiring someone isn’t in the cards, these online platforms can help:\n\nBioRender. Super popular with molecular biologists, packed with templates and illustrations. Downsides? It’s super pricey.\nNIH BioArt Source. Free and provided by NIH.\nBio Icons. Free as well.\nAdobe Stock. High-quality stuff from Adobe, but yeah, like other Adobe products, it’s expensive.\n\nUse AI. AI tools are getting pretty good at making custom illustrations. Just tread carefully—AI-generated stuff isn’t always perfect, and you don’t want to end up with something embarrassing (Here’s a cringe-worthy example).\n\n\n\nAnother great side benefit of editing this in Powerpoint is that that you can esaily animate your figures when you present in conferences or group meetings. We will demonstratre in class how to do this.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>First Publication-Ready Figure</span>"
    ]
  },
  {
    "objectID": "PSet1.html",
    "href": "PSet1.html",
    "title": "\n7  PSet 1\n",
    "section": "",
    "text": "7.1 Why Correlation is NOT Causation\nHello there! Welcome to your first PSet. This time, we’re going to use your R plotting skills to make your data visualizations pop.\nSo, get your creativity (and code) fired up. Let’s begin!\nWe’ve all heard it a thousand times: Correlation does not imply causation. A great example is that nations which consume more chocolate per capita tend to have more Nobel Prize winners per 10 million citizens. I highly doubt if any doctor would advise you that eating more chocolate is your ticket to Stockholm.\nThe data for chocolate consumption (Chocolate) and the number of Nobel laureates (Nobel) in various countries is here:\ndata_nobel &lt;- read.csv(\"http://clsong.com/assets/class_data/data_nobel.csv\")\nWe could do a quick scatter plot to see the relationship between the two variables:\nlibrary(tidyverse)\n\nggplot(\n    data = data_nobel,\n    aes(x = Chocolate, y = Nobel)\n) +\n    geom_point() +\n    theme_bw()\nThis quick plot is, well, meh. It’s not something you’d proudly show in your paper or presentation. For example, in the original paper that published this result, the figure looked much better:\nLet’s transform the quick plot into something more publication-ready. Specifically, your plot must include:\nOf course, you can do so much more than that. Explore and be creative!",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>PSet 1</span>"
    ]
  },
  {
    "objectID": "PSet1.html#why-correlation-is-not-causation",
    "href": "PSet1.html#why-correlation-is-not-causation",
    "title": "\n7  PSet 1\n",
    "section": "",
    "text": "Messerli, F. H. (2012). Chocolate consumption, cognitive function, and nobel laureates. New England Journal of Medicine\n\n\n\nA Title that clearly shows the message of the plot.\nCountry flags instead of points.\nA correlation coefficient on the plot.\nReadable text sizes. Make sure axis labels, titles, etc., are big enough to see clearly.\n\n\n\n\n\n\n\n\nHelpful tools\n\n\n\n\n\nWe did not cover everything in the class, but it is easy to learn new ggplot2 tricks. Below are some potentially useful resources:\n\nHow to add country flags? You can use the geom from ggflags::geom_flag() to do this. The Flag column in the data contains the country codes. So it would be something like ggflags::geom_flag(aes(country = Flag)).\nHow to add a correlation coefficient to the plot? You can use the ggpubr::stat_cor() package to do this.\nHow to indicate the data source? To give due credit to the original author of the data, you can use the caption argument in the labs() function.\n(Optional) add the country names to the plot. You can use the ggrepel::geom_text_repel() function to do this.\n\n\n\n\n\n\n\n\n\n\nMy example plot\n\n\n\n\n\nAs one example, below is a figure that I created using the hrbrthemes package. This is just some reference to help you navigate. I am looking forward to losing to you.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>PSet 1</span>"
    ]
  },
  {
    "objectID": "PSet1.html#keeping-up-with-the-new-york-times",
    "href": "PSet1.html#keeping-up-with-the-new-york-times",
    "title": "\n7  PSet 1\n",
    "section": "\n7.2 Keeping up with the New York Times",
    "text": "7.2 Keeping up with the New York Times\nThe New York Times often publishes elegant data visualizations. In this problem, we’ll mimic one of their COVID-19 vaccination rate vs. GDP charts. Their graph is below:\n\n\nFrom New York Times\n\nWe’ll use a smaller dataset that approximates what they used. Even if it’s not the exact same dataset, the design principles remain the same. To load the data into your R environment, run the following code:\n\ndata_nyt &lt;- read.csv(\"http://clsong.com/assets/class_data/data_nyt.csv\")\n\nIn this problem, please build an NYT-style plot for this plot. You can add more features to make your plot more informative and visually appealing, but it needs to have at least the following requirement:\n\nBecause GDP spans large orders of magnitude, the x-axis should be in log scale.\nDistinguish points by continent (instead of the income group in the original figure).\nWe want bigger bubbles for more populous countries.\nCustomized color/fill palette. Don’t just rely on default color scales. Find a palette you like.\nAdd the $ logo on the x-axis.\n\n\n\n\n\n\n\nHelpful tools\n\n\n\n\n\n\nAs we mentioned, x axis is also an aes, so it is also controlled by scale_*(). Google or ask ChatGPT how to do this.\nYou can use the scales::label_currency() function to format the axis labels.\n\n\n\n\n\n\n\n\n\n\nMy example plot\n\n\n\n\n\nAgain, just for refernece purpose. I am looking forward to seeing your more creative and informative plots.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>PSet 1</span>"
    ]
  },
  {
    "objectID": "08_dplyr.html",
    "href": "08_dplyr.html",
    "title": "8  Six verbs for data transformation",
    "section": "",
    "text": "8.1 What is pipe?\nWe’ll pause our visualization work for a moment to focus on a crucial phase of data analysis: data wrangling. Data wrangling is the process of importing, tidying, and transforming data so that it’s easier to analyze and visualize. By mastering these skills, you’ll be able to spend less time on annoying details but more time on actual research. We will start with transofmation.\nThe dplyr package offers an especially elegant way to handle data transformation in R. In this section, we’ll introduce six core functions (often called “verbs”) that cover the basics: they let you arrange rows, filter rows, select columns, create or modify columns, group data, and summarize data. We’ll use the penguins dataset as our guide, along with tidylog package to keep track of what happens under the hood.\nIn the tidyverse, the pipe operator |&gt; is a central tool that allows you to link together multiple functions in a step-by-step sequence. Think of it as a chain: the output of one function becomes the input of the next. This approach makes code more readable and easier to understand. When you use a pipe:\nGiven how often you’ll use the pipe, it helps to memorize the shortcut: Ctrl + Shift + M (Windows) or Cmd + Shift + M (Mac) in RStudio automatically inserts a pipe operator. You can also change which pipe operator you use in RStudio by going to Tools &gt; Global Options &gt; Code &gt; Editing &gt; Use native pipe operator.",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Six verbs for data transformation</span>"
    ]
  },
  {
    "objectID": "08_dplyr.html#what-is-pipe",
    "href": "08_dplyr.html#what-is-pipe",
    "title": "8  Six verbs for data transformation",
    "section": "",
    "text": "You start with a tibble as your first argument.\nEvery additional function that follows manipulates the tibble in some way.\nThe result is always a new tibble.\n\n\n|&gt; pipe%&gt;% pipe\n\n\nIf you’re using R version 4.1 or later, you can write:\n\n1data |&gt;\n    function1() |&gt; \n    function2()\n\n\n1\n\nThe |&gt; pipe operator is used to pass the output of one function as the input to the next function.\n\n\n\n\n\n\nIf you have an older version of R, you might still use the magrittr pipe %&gt;% (automatically loaded with tidyverse):\n\ndata %&gt;%\n    function1() %&gt;%\n    function2()",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Six verbs for data transformation</span>"
    ]
  },
  {
    "objectID": "08_dplyr.html#arrange",
    "href": "08_dplyr.html#arrange",
    "title": "8  Six verbs for data transformation",
    "section": "8.2 arrange()",
    "text": "8.2 arrange()\narrange() reorders the rows of your tibble based on the values in one or more columns. For example, to sort the penguins dataset by bill length (from smallest to largest):\n\npenguins |&gt;\n1    arrange(bill_length_mm)\n\n\n1\n\nWithin arrange function, put in the variable name (column) that you want to sort by.\n\n\n\n\n\n  \n\n\n\nTo sort in descending order, add a minus sign (-) before the column name:\n\npenguins |&gt;\n1    arrange(-bill_length_mm)\n\n\n1\n\nThe minus sign - before the column name will sort the column in descending order.\n\n\n\n\n\n  \n\n\n\n\nExercise\nSort the penguins dataset by island first, then by descending bill_depth_mm.\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Six verbs for data transformation</span>"
    ]
  },
  {
    "objectID": "08_dplyr.html#filter",
    "href": "08_dplyr.html#filter",
    "title": "8  Six verbs for data transformation",
    "section": "8.3 filter()",
    "text": "8.3 filter()\nfilter() selectively retains rows based on certain conditions. Suppose you want to keep only the Adelie penguins:\n\npenguins |&gt;\n1    filter(species == \"Adelie\")\n\n\n1\n\nWithin filter function, put in the condition you want to filter by. Note that it is == for equal not =.\n\n\n\n\nfilter: removed 192 rows (56%), 152 rows remaining\n\n\n\n  \n\n\n\nYou can combine multiple conditions with logical operators. For instance, filter for Adelie penguins that are male:\n\npenguins |&gt;\n1    filter(species == \"Adelie\" & sex == \"male\")\n\n\n1\n\nUse the & operator to combine multiple conditions.\n\n\n\n\nfilter: removed 271 rows (79%), 73 rows remaining\n\n\n\n  \n\n\n\nTo allow for “either/or” conditions, you can use the | operator or the %in% function. Below, we keep rows where the species is Adelie or Chinstrap:\n\n| operator%in% function\n\n\n\npenguins |&gt;\n1    filter(species == \"Adelie\" | species == \"Chinstrap\")\n\n\n1\n\nUse the | operator to combine multiple conditions.\n\n\n\n\nfilter: removed 124 rows (36%), 220 rows remaining\n\n\n\n  \n\n\n\n\n\nThis is particularly useful when you have many values to filter.\n\npenguins |&gt;\n1    filter(species %in% c(\"Adelie\", \"Chinstrap\"))\n\n\n1\n\nUse the %in% function to filter rows based on multiple values.\n\n\n\n\nfilter: removed 124 rows (36%), 220 rows remaining\n\n\n\n  \n\n\n\n\n\n\n\nExercise\nFilter the penguins dataset for male penguins with bill length less than 40 mm, living on either Torgersen or Biscoe island.\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Six verbs for data transformation</span>"
    ]
  },
  {
    "objectID": "08_dplyr.html#select",
    "href": "08_dplyr.html#select",
    "title": "8  Six verbs for data transformation",
    "section": "8.4 select()",
    "text": "8.4 select()\nWhere filter() chooses rows, select() helps you choose columns. For instance, if you’re only interested in species, island, and the two bill measurements:\n\npenguins |&gt;\n1    select(species, island, bill_length_mm, bill_depth_mm)\n\n\n1\n\nList the columns you want inside select().\n\n\n\n\nselect: dropped 4 variables (flipper_length_mm, body_mass_g, sex, year)\n\n\n\n  \n\n\n\nIf you want to remove specific columns, put a minus sign in front of each column name:\n\npenguins |&gt;\n1    select(-island)\n\n\n1\n\nThe minus sign - before the column name will exclude the column from the output.\n\n\n\n\nselect: dropped one variable (island)\n\n\n\n  \n\n\n\n\n\n\n\n\n\nChange the column orders\n\n\n\n\n\nYou can rearrange columns simply by listing them in the order you want:\n\npenguins |&gt; \n    select(bill_depth_mm, bill_length_mm, species)\n\nselect: dropped 5 variables (island, flipper_length_mm, body_mass_g, sex, year)\n\n\n\n  \n\n\n\n\n\n\n\nExercise\nSelect the species, year, body_mass_g columns from the penguins dataset.\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Six verbs for data transformation</span>"
    ]
  },
  {
    "objectID": "08_dplyr.html#mutate",
    "href": "08_dplyr.html#mutate",
    "title": "8  Six verbs for data transformation",
    "section": "8.5 mutate()",
    "text": "8.5 mutate()\nmutate() allows you to create new columns or change existing ones. This name is often considered the least intutive in tidyverse, but I guess it makes the most sense for our department :)\nFor example, suppose you want to create a new column called bill_ratio—which is bill length divided by bill depth—and also adjust the year column so that the year 2017 becomes your new “zero” starting point:\n\npenguins |&gt;\n1    mutate(bill_ratio = bill_length_mm / bill_depth_mm) |&gt;\n2    mutate(year = year - 2017)\n\n\n1\n\nWithin mutate function, put in the new column name and the calculation.\n\n2\n\nWe subtract 2017 from the existing year column so that 2017 becomes year 0. This new column replaces the previous one\n\n\n\n\nmutate: new variable 'bill_ratio' (double) with 338 unique values and 1% NA\nmutate: converted 'year' from integer to double (0 new NA)\n\n\n\n  \n\n\n\nA very useful trick is to combine mutate() with conditional functions like if_else() (two conditions) or case_when() (multiple conditions):\n\nif_else()case_when()\n\n\n\npenguins |&gt;\n1    mutate(bill_ratio = bill_length_mm / bill_depth_mm) |&gt;\n2    mutate(bill_category = if_else(bill_ratio &gt; 2, \"long\", \"short\"))  |&gt;\n3    select(species, bill_category)\n\n\n1\n\nCreate a new column bill_ratio that is the ratio of bill_length_mm to bill_depth_mm.\n\n2\n\nCreate a new column bill_category that is long if bill_ratio is greater than 2, otherwise short.\n\n3\n\nSelect only the species and bill_category columns.\n\n\n\n\nmutate: new variable 'bill_ratio' (double) with 338 unique values and 1% NA\nmutate: new variable 'bill_category' (character) with 3 unique values and 1% NA\nselect: dropped 8 variables (island, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, …)\n\n\n\n  \n\n\n\n\n\n\npenguins |&gt;\n    mutate(bill_ratio = bill_length_mm / bill_depth_mm) |&gt;\n1    mutate(bill_category = case_when(\n2        bill_ratio &gt; 2 ~ \"long\",\n3        bill_ratio &lt; 1.5 ~ \"short\",\n4        TRUE ~ \"medium\"\n    ))  |&gt; \n    select(species, bill_category)\n\n\n1\n\nCreate a new column bill_category based on the conditions.\n\n2\n\nIf bill_ratio is greater than 2, then bill_category is long.\n\n3\n\nIf bill_ratio is less than 1.5, then bill_category is short.\n\n4\n\nIf none of the above conditions are met, then bill_category is medium.\n\n\n\n\nmutate: new variable 'bill_ratio' (double) with 338 unique values and 1% NA\nmutate: new variable 'bill_category' (character) with 2 unique values and 0% NA\nselect: dropped 8 variables (island, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, …)\n\n\n\n  \n\n\n\n\n\n\n\nExercise\nCreate a new column bill_area (the product of bill_length_mm and bill_depth_mm). Label those with bill_area &gt; 700 as “big” and everything else as “small”. Finally, select only three columns: species, bill_area, and bill_category.\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Six verbs for data transformation</span>"
    ]
  },
  {
    "objectID": "08_dplyr.html#group_by",
    "href": "08_dplyr.html#group_by",
    "title": "8  Six verbs for data transformation",
    "section": "8.6 group_by()",
    "text": "8.6 group_by()\nWe’ve dealt with rows and columns individually, but one of the greatest strengths of dplyr is its ability to handle groups. With group_by(), you tell R to treat subsets of your data as separate groups based on one or more columns. For example:\n\npenguins |&gt;\n1    group_by(species)\n\n\n1\n\nWithin group_by function, specify the column(s) you want to group by.\n\n\n\n\ngroup_by: one grouping variable (species)\n\n\n\n  \n\n\n\nOnce data is grouped, you can apply other operations such as filter() or mutate() within each group. For example, to keep only penguins whose bill length is above the mean bill length for their own species (use filter()):\n\npenguins |&gt;\n    group_by(species) |&gt;\n1    filter(bill_length_mm &gt; mean(bill_length_mm, na.rm = TRUE))  |&gt;\n2    ungroup()\n\n\n1\n\nFilter the penguins dataset to only penguins with bill_length_mm greater than the mean bill_length_mm for each species.\n\n2\n\nUse ungroup to remove the grouping.\n\n\n\n\ngroup_by: one grouping variable (species)\nfilter (grouped): removed 172 rows (50%), 172 rows remaining (removed 0 groups, 3 groups remaining)\nungroup: no grouping variables remain\n\n\n\n  \n\n\n\nNote that it is generally a good practice to use ungroup() after you are done with the grouping. This hs been the source of many bugs in real-world data analysis.\nSimilarly, you might standardize bill lengths by species for better comparisons (use mutate()):\n\npenguins |&gt;\n    group_by(species) |&gt;\n1    mutate(scaled_bill_length =\n    (bill_length_mm - mean(bill_length_mm, na.rm = TRUE)) /\n    sd(bill_length_mm, na.rm = TRUE) ) |&gt;\n    ungroup()  |&gt; \n2    select(species, bill_length_mm, scaled_bill_length)\n\n\n1\n\nCreate a new column scaled_bill_length that is the standardized bill_length_mm for each species.\n\n2\n\nSelect only the species, bill_length_mm, and scaled_bill_length columns.\n\n\n\n\ngroup_by: one grouping variable (species)\nmutate (grouped): new variable 'scaled_bill_length' (double) with 209 unique values and 1% NA\nungroup: no grouping variables remain\nselect: dropped 6 variables (island, bill_depth_mm, flipper_length_mm, body_mass_g, sex, …)\n\n\n\n  \n\n\n\n\nExercise\nGroup by both species and sex, then filter for penguins whose bill_length_mm is greater than the mean plus one standard deviation for their species-and-sex group.\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Six verbs for data transformation</span>"
    ]
  },
  {
    "objectID": "08_dplyr.html#summarize",
    "href": "08_dplyr.html#summarize",
    "title": "8  Six verbs for data transformation",
    "section": "8.7 summarize()",
    "text": "8.7 summarize()\nOnce you’ve grouped your data, summarize helps you collapse each group into summary results per grouping category. For instance, to compute the average bill_length_mm by species:\n\npenguins |&gt;\n    group_by(species) |&gt;\n1    summarize(\n2        avg_bill_length = mean(bill_length_mm, na.rm = TRUE)\n    ) \n\n\n1\n\nWithin summarize function, put in the new column name and the calculation.\n\n2\n\nCalculate the average bill_length_mm for each species. The na.rm = TRUE argument is used to remove missing values (NAs).\n\n\n\n\ngroup_by: one grouping variable (species)\nsummarize: now 3 rows and 2 columns, ungrouped\n\n\n\n  \n\n\n\nNotice that it has also removed the ungrouped columns. This is a feature, not a bug.\nWe can also get more than one summary results. For example, we can get the mean and variance of bill_length_mm for each species and each sex:\n\npenguins |&gt;\n    group_by(species, sex)  |&gt; \n    summarize(mean_bill_length = mean(bill_length_mm, na.rm = TRUE), \n              var_bill_length = var(bill_length_mm, na.rm = TRUE))\n\ngroup_by: 2 grouping variables (species, sex)\nsummarize: now 8 rows and 4 columns, one group variable remaining (species)\n\n\n\n  \n\n\n\n\nExercise\nGroup the penguins dataset by island and sex. Then calculate the average bill_length_mm and bill_depth_mm for each group.\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Six verbs for data transformation</span>"
    ]
  },
  {
    "objectID": "08_dplyr.html#combine-verbs-for-complicated-tasks",
    "href": "08_dplyr.html#combine-verbs-for-complicated-tasks",
    "title": "8  Six verbs for data transformation",
    "section": "8.8 Combine verbs for complicated tasks",
    "text": "8.8 Combine verbs for complicated tasks\nBy now, you’ve seen how each of these six verbs works. In practice, you’ll often chain them together to tackle more involved questions. Here’s an example where we examine the difference in bill area between male and female penguins in the year 2009. Specifically, we’ll compute the mean and standard deviation of bill area per species, reorder the columns to place sex before species, and sort by descending mean bill size:\n\npenguins |&gt; \n    filter(year == 2009) |&gt;\n    mutate(bill_area = bill_length_mm * bill_depth_mm) |&gt;\n    group_by(species, sex)  |&gt;\n    summarize(\n        mean_bill_size = mean(bill_area, na.rm = TRUE),\n        sd_bill_size = sd(bill_area, na.rm = TRUE)\n    )  |&gt; \n    ungroup() |&gt;\n    select(sex, species, mean_bill_size, sd_bill_size) |&gt;\n    arrange(-mean_bill_size)\n\nfilter: removed 224 rows (65%), 120 rows remaining\nmutate: new variable 'bill_area' (double) with 120 unique values and 1% NA\ngroup_by: 2 grouping variables (species, sex)\nsummarize: now 7 rows and 4 columns, one group variable remaining (species)\nungroup: no grouping variables remain\nselect: columns reordered (sex, species, mean_bill_size, sd_bill_size)\n\n\n\n  \n\n\n\nBy weaving together these verbs, you can accomplish nuanced data transformations in just a few lines of code.",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Six verbs for data transformation</span>"
    ]
  },
  {
    "objectID": "09_tidyr.html",
    "href": "09_tidyr.html",
    "title": "9  Five verbs for tidying data",
    "section": "",
    "text": "9.1 pivot_longer()\nIt’s often said that data cleaning and preparation consume the lion’s share of an analyst’s time—some claim as much as 80%. When real-world data arrives on your desk, chances are it isn’t in a convenient format. Columns may be mislabeled or scattered, variable names might be confusing, and rows may contain missing information. Over the years, analysts have discovered that a consistent “tidy” format for data is invaluable: it lets you focus on extracting insights rather than wrangling columns and rows into submission.\nIn practical terms—and echoing our earlier discussion—a tidy dataset has these defining traits:\nThe tidyr package (part of the tidyverse) is designed to help transform messy data into this tidy structure. In this chapter, we’ll explore some of the most commonly used tidyr functions, using example datasets that demonstrate where each function shines. We’ll pause our use of the penguins dataset momentarily, because it’s already tidy; instead, we’ll rely on some datasets from dcldata to illustrate typical data-wrangling challenges.\nLet’s begin with the example_eagle_nests dataset from U.S. Fish and Wildlife Service:\nexample_eagle_nests\nNotice that 2017 and 2019 are stored as column names, but they’re really values (i.e., years). This is a classic “wide” format. We can use pivot_longer() to convert it into a tidy format:\neagle_nests_longer &lt;- example_eagle_nests |&gt;\n1    pivot_longer(\n2        cols = c(`2007`, `2009`),\n3        names_to = \"year\",\n4        values_to = \"nests\"\n    )\neagle_nests_longer\n\n\n1\n\npivot_longer() transforms wide data into a longer, “tall” format.\n\n2\n\ncols specifies the columns to pivot.\n\n3\n\nnames_to creates a new column holding the former column names.\n\n4\n\nvalues_to creates a new column holding the values previously spread across multiple columns.\nWhy are “year” and “nests” in quotes? Because they are new column names that we are creating. As a general rule, when pivoting, we should always use quotes when creating new columns.\nSpecifying the columns can sometimes feel like using select(). For instance, you can list the columns to include, or exclude the columns you want to keep untouched. The code below achieves the same result by excluding everything but region:\nexample_eagle_nests |&gt;\n    pivot_longer(\n        cols = -c(region), \n        names_to = \"year\", \n        values_to = \"nests\" \n    )",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Five verbs for tidying data</span>"
    ]
  },
  {
    "objectID": "09_tidyr.html#pivot_longer",
    "href": "09_tidyr.html#pivot_longer",
    "title": "9  Five verbs for tidying data",
    "section": "",
    "text": "Exercise\nTry your hand on the billboard dataset (in the tidyverse). This dataset has columns labeled by week (wk1 through wk76), but we want a tidy format that moves those week columns into a single “week” variable and the rankings into another “rank” variable. Use pivot_longer() to make it happen.\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Five verbs for tidying data</span>"
    ]
  },
  {
    "objectID": "09_tidyr.html#pivot_wider",
    "href": "09_tidyr.html#pivot_wider",
    "title": "9  Five verbs for tidying data",
    "section": "9.2 pivot_wider()",
    "text": "9.2 pivot_wider()\nThe pivot_wider() function reverses what pivot_longer() does, turning long datasets into wide formats. Suppose you want to revert our eagle_nests_longer data back to its original shape:\n\neagle_nests_longer |&gt;\n1    pivot_wider(\n2        names_from = \"year\",\n3        values_from = \"nests\"\n    )\n\n\n1\n\npivot_wider() transforms long data into a wider format.\n\n2\n\nnames_from identifies which column contains the new column names.\n\n3\n\nvalues_from identifies the column whose values will fill the new cells.\n\n\n\n\n\n  \n\n\n\nLet’s see a more practical example with our penguins dataset. Perhaps we want to compare bill length between male and female penguins for each species. We can create a summary of the mean bill length by species and sex, then convert that summary into a wide layout:\n\nCalculate the meanSex as columnsVisualize differences\n\n\nWe firstly use our hard-earned data transformation skills to calculate the mean bill length by the groups\n\nlibrary(palmerpenguins)\n\npenguins |&gt;\n   group_by(species, sex) |&gt;\n   summarise(mean_bill_length = mean(bill_length_mm)) \n\n\n  \n\n\n\n\n\nBecause comparing values side by side can be clearer, let’s pivot the data wider:\n\npenguins |&gt;\n   group_by(species, sex) |&gt;\n   summarise(mean_bill_length = mean(bill_length_mm)) |&gt;\n   ungroup() |&gt;\n   pivot_wider(\n      names_from = \"sex\",\n      values_from = \"mean_bill_length\"\n   )\n\n\n  \n\n\n\n\n\nWe can go one step further and visualize how male and female bill lengths compare:\n\npenguins |&gt;\n   group_by(species, sex) |&gt;\n   summarise(mean_bill_length = mean(bill_length_mm)) |&gt;\n   ungroup() |&gt;\n   pivot_wider(\n      names_from = \"sex\",\n      values_from = \"mean_bill_length\"\n   ) |&gt;\n   ggplot(aes(male, female)) +\n   geom_point(size = 4) +\n   ggrepel::geom_text_repel(aes(label = species), box.padding = 1) +\n   geom_abline(intercept = 0, slope = 1) +\n   jtools::theme_nice()\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\nThe dataset us_rent_income (from the tidyverse) contains 2017 American Community Survey data, where variable indicates whether it’s yearly income or monthly rent, and estimate gives the numeric value. Use pivot_wider() to reshape, then calculate the ratio of annual rent to income, and finally sort the results by that ratio.\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Five verbs for tidying data</span>"
    ]
  },
  {
    "objectID": "09_tidyr.html#separate",
    "href": "09_tidyr.html#separate",
    "title": "9  Five verbs for tidying data",
    "section": "9.3 separate()",
    "text": "9.3 separate()\nThe separate() function allows you to split one column into multiple columns. Consider the example_gymnastics_2 dataset from dcldata, which tracks women’s Olympic gymnastic scores for 2012 and 2016:\n\nexample_gymnastics_2\n\n\n  \n\n\n\nThe column names aren’t tidy. First, let’s pivot everything into a long format:\n\nexample_gymnastics_2 |&gt;\n    pivot_longer(\n        cols = -c(`country`), \n        names_to = \"eventandyear\", \n        values_to = \"score\"\n    )\n\n\n  \n\n\n\nWe see that the new event_year column contains both an event name and a year (like vault_2012). We can split this into two columns—event and year—using separate():\n\nexample_gymnastics_2 |&gt;\n    pivot_longer(\n        cols = -c(`country`), \n        names_to = \"eventandyear\", \n        values_to = \"score\"\n    ) |&gt;\n    separate(\n        col = \"eventandyear\", \n        into = c(\"event\", \"year\"), \n        sep = \"_\"\n    )\n\n\n  \n\n\n\n\n\n\n\n\n\nunite()\n\n\n\n\n\nWhile separate() splits columns, unite() does the opposite: it combines multiple columns into one.\nFor a simple example, imagine that we’ve separated out the month, day, and year of a date into three columns (month, day, year), but now we want a single date column again. Let’s illustrate with a small toy dataset:\n\ntoy_dates &lt;- tibble(\n  month = c(1, 2, 3),\n  day   = c(15, 20, 25),\n  year  = c(2020, 2020, 2020)\n)\n\nWe can re-combine these columns into one:\n\ntoy_dates |&gt;\n1  unite(\n2    col = \"full_date\",\n3    month, day, year,\n4    sep = \"-\"\n  )\n\n\n1\n\nunite() creates a new column (col = “full_date”) from the listed columns (month, day, year).\n\n2\n\nThe new column is named “full_date”.\n\n3\n\nThe columns to combine are month, day, and year.\n\n4\n\nsep = “-” indicates how to join the columns (here, with a dash).\n\n\n\n\n\n  \n\n\n\n\n\n\n\nExercise\nNow let’s tidy the who2 dataset (from the tidyverse). Columns like sp_m_014 combine multiple pieces of information—diagnosis method (sp), gender (m), and age group (014). Your task:\n\nConvert the data into a long format using pivot_longer().\nSplit the combined column into three separate columns (diagnosis, gender, age) using separate().\n\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Five verbs for tidying data</span>"
    ]
  },
  {
    "objectID": "09_tidyr.html#drop_na-and-replace_na",
    "href": "09_tidyr.html#drop_na-and-replace_na",
    "title": "9  Five verbs for tidying data",
    "section": "9.4 drop_na() and replace_na()",
    "text": "9.4 drop_na() and replace_na()\nWhen dealing with real-world data, missing values (often represented by NA in R) are unavoidable. It is a very broad topic and usually question-specific. However, we show two functions that help you manage missing data (a really bad story here). The main point is that you should ALWAYS be explict about how you handle missing data.\n\n9.4.1 drop_na()\nThe function drop_na() removes rows that contain any missing values in the specified columns. This can be handy when a row is so incomplete that it’s unusable for analysis.\nFor example, let’s look at a look from the penguins dataset (pretend we didn’t want to keep partial observations):\n\npenguins\n\n\n  \n\n\n\nWe can drop any row with missing data simply by doing:\n\npenguins |&gt;\n1  drop_na()\n\n\n1\n\ndrop_na() removes rows with missing values.\n\n\n\n\ndrop_na: removed 11 rows (3%), 333 rows remaining\n\n\n\n  \n\n\n\nIf you only care about missing values in particular columns (say, bill_length_mm), you can specify them as arguments:\n\npenguins |&gt;\n1  drop_na(bill_length_mm)\n\n\n1\n\ndrop_na() removes rows with missing values in the bill_length_mm column.\n\n\n\n\ndrop_na: removed 2 rows (1%), 342 rows remaining\n\n\n\n  \n\n\n\n\n\n9.4.2 replace_na()\nSometimes you don’t want to drop missing values—you might prefer to fill them with a default value or placeholder. The replace_na() function allows you to do exactly that.\nFor instance, if we believe that the missing sex is most likely to be male, we can replace the missing values with that assumption:\n\npenguins |&gt;\n  replace_na(\n1   list(sex = 'male')\n  )\n\n\n1\n\nReplaces missing values in the sex column as specified.\n\n\n\n\nreplace_na: changed 11 values (3%) of 'sex' (11 fewer NAs)",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Five verbs for tidying data</span>"
    ]
  },
  {
    "objectID": "09_tidyr.html#tidy-a-real-dataset",
    "href": "09_tidyr.html#tidy-a-real-dataset",
    "title": "9  Five verbs for tidying data",
    "section": "9.5 Tidy a real dataset",
    "text": "9.5 Tidy a real dataset\nLet’s explore the famous Datasaurus dataset, which perfectly illustrates why visualizing your data is crucial (more info). This dataset contains multiple distributions that have identical summary statistics but look completely different when plotted.\n\nlibrary(tidyverse)\n# pak::pkg_install(\"datasauRus\")\nlibrary(datasauRus)\n\n1datasaurus_dozen_wide\n\n\n1\n\ndatasaurus_dozen_wide is the wide format of the Datasaurus dataset.\n\n\n\n\n\n  \n\n\n\nLet’s tidy this dataset in three steps:\n\nFirst, we’ll transform it from wide to long format:\n\n\ndatasaurus_dozen_long &lt;- datasaurus_dozen_wide |&gt;\n1  mutate(row = row_number()) |&gt;\n  pivot_longer(\n2    cols = -\"row\",\n3    names_to = \"variable\",\n4    values_to = \"value\"\n  )\n\n\n1\n\nmutate(row = row_number()) adds a row identifier.\n\n2\n\npivot_longer() pivots the data from wide to long format.\n\n3\n\nnames_to creates a new column holding the former column names.\n\n4\n\nvalues_to creates a new column holding the values previously spread across multiple columns.\n\n\n\n\nmutate: new variable 'row' (integer) with 142 unique values and 0% NA\npivot_longer: reorganized (away_x, away_y, bullseye_x, bullseye_y, circle_x, …) into (variable, value) [was 142x27, now 3692x3]\n\n\n\ndatasaurus &lt;- datasaurus_dozen_long |&gt;\n  separate(\n    variable, \n    into = c(\"dataset\", \"coord\"),\n1    sep = \"_(?=[^_]*$)\"\n  ) |&gt;\n2  pivot_wider(\n    names_from = \"coord\", \n    values_from = \"value\"\n  )\n\n\n1\n\nSplit at last underscore\n\n2\n\npivots the data from long to wide format.\n\n\n\n\npivot_wider: reorganized (coord, value) into (x, y) [was 3692x4, now 1846x4]\n\ndatasaurus\n\n\n  \n\n\n\nNow we can demonstrate why this dataset is famous. First, let’s check the summary statistics:\n\n# Calculate summary statistics for each dataset\ndatasaurus |&gt;\n  group_by(dataset) |&gt;\n  summarise(\n    mean_x = mean(x),\n    mean_y = mean(y),\n    sd_x = sd(x),\n    sd_y = sd(y),\n    cor = cor(x, y)\n  )\n\ngroup_by: one grouping variable (dataset)\nsummarise: now 13 rows and 6 columns, ungrouped\n\n\n\n  \n\n\n\nDespite having nearly identical summary statistics, when we visualize the data, we see that each dataset forms a completely different shape:\n\n# Create faceted scatter plots\ndatasaurus |&gt;\n  ggplot(aes(x, y, color = dataset)) +\n  geom_point() +\n  facet_wrap(vars(dataset)) +\n  jtools::theme_nice() +\n  theme(legend.position = \"none\") +\n  labs(title = \"Same summary statistics, very different distributions\")\n\n\n\n\n\n\n\n\nThis example demonstrates why it’s essential to both analyze AND visualize your data!",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Five verbs for tidying data</span>"
    ]
  },
  {
    "objectID": "10_import_data.html",
    "href": "10_import_data.html",
    "title": "10  Import and Join Data",
    "section": "",
    "text": "10.1 File structure\nSo far, we’ve only worked with data bundled inside packages. In real-world scenarios, however, data is often stored in external files—like Excel or CSV—and may be spread across multiple files. To get it all into one tidy tibble, we typically import the data first, then merge the datasets using the appropriate joining functions. Let’s begin by loading the packages we’ve been using all along:\nThe layout of your files and directories can be crucial for smooth data work. As someone who routinely run other people’s code, I can’t stress enough how important it is to adopt good file-management practices.",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Import and Join Data</span>"
    ]
  },
  {
    "objectID": "10_import_data.html#file-structure",
    "href": "10_import_data.html#file-structure",
    "title": "10  Import and Join Data",
    "section": "",
    "text": "By Jenny Bryan, source\n\n\n\nProper approach: Using an RStudio ProjectShortcut: Opening R code in RStudio\n\n\nAn excellent practice is to create an RStudio Project. This makes it easier to keep all your scripts, data, and output in one organized place and ensures file paths don’t become nightmares. See official Guideline\n\n\nIf you’re short on time and simply want to test a single script, you can open the R code file directly in RStudio. But remember, it’s best to use a Project in the long run.",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Import and Join Data</span>"
    ]
  },
  {
    "objectID": "10_import_data.html#import-data",
    "href": "10_import_data.html#import-data",
    "title": "10  Import and Join Data",
    "section": "10.2 Import data",
    "text": "10.2 Import data\nThe simplest way to import data in RStudio is to click Import Dataset, navigate to your file, and let RStudio generate the code for you. Here’s an example where we import a CSV containing per-capita CO₂ data, taken from Our World in Data:\n\nread_csv(\"data/per-capita-co-emissions.csv\")\n\n\n  \n\n\n\nFor cleaner column names, the janitor package offers a handy function called clean_names(). It converts column headers into lower-case words separated by underscores (among other things). Let’s see it in action:\n\n# if you don't have the janitor package installed, you can install it with the following command\n# pak::pkg_install(\"janitor\")\n\nread_csv(\"data/per-capita-co-emissions.csv\")  |&gt; \n    janitor::clean_names()\n\n\n  \n\n\n\nThis often saves you time and frustration, especially when working with large or messy real-world datasets. It has been a time-saver for me on many occasions.\nAdditionally, we should rename() the columns to make them more readable.\n\ndata_co2 &lt;- read_csv(\"data/per-capita-co-emissions.csv\")  |&gt; \n1    janitor::clean_names()  |&gt;\n2    rename(\n3        co2 = annual_co2_emissions_per_capita\n    )\n\n\n1\n\nWe use the clean_names() function to make column names more readable.\n\n2\n\nWe use the rename() function to rename the column.\n\n3\n\nWe rename the column annual_co2_emissions_per_capita to co2.\n\n\n\n\nRows: 94 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): Entity\ndbl (2): Year, Annual CO₂ emissions (per capita)\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nrename: renamed one variable (co2)\n\n\nAs always, let’s do a quick plot to sense-check our data:\n\ndata_co2 |&gt; \n    ggplot(aes(x = year, y = co2)) +\n1    geom_line() +\n    labs(\n        x = \"Year\",\n        y = \"Annual CO2 emissions per capita\"\n    ) +\n    jtools::theme_nice()\n\n\n1\n\nWe use a line plot to show the evolution of CO2 emissions over time.\n\n\n\n\n\n\n\n\n\n\n\nWe see emissions rising across the years, but the real question might be how CO₂ levels relate to global temperature. For that, we’ll need to import temperature data and then join both datasets together.",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Import and Join Data</span>"
    ]
  },
  {
    "objectID": "10_import_data.html#join-relational-data",
    "href": "10_import_data.html#join-relational-data",
    "title": "10  Import and Join Data",
    "section": "10.3 Join Relational Data",
    "text": "10.3 Join Relational Data\nWe can fetch temperature data—also from Our World in Data—and load it similarly:\n\ndata_temp &lt;- read_csv(\"data/temperature-anomaly.csv\") |&gt; \n    janitor::clean_names()  |&gt; \n    select(year, global_average_temperature_anomaly_relative_to_1961_1990) |&gt;\n    rename(temp_anomaly = global_average_temperature_anomaly_relative_to_1961_1990)\n\ndata_temp\n\n\n  \n\n\n\nNow we have two data frames: data_co2 and data_temp. Both contain a year column, which we can use as the “key” for joining. The left_join() function retains all rows of the left data frame (data_co2 in this case) and matches where possible:\n\ndata_co2  |&gt; \n    left_join(\n        data_temp, \n        by = \"year\"\n    ) \n\n\n  \n\n\n\nNotice that joins are asymmetric. Switching the order to left_join(data_temp, data_co2, by = \"year\") wouldn’t produce the same result. A left join always keeps every row from the left-hand dataset, filling missing matches from the right dataset with NA. I highly recommend to stick to left_join() for consistency (and also forces you to think about which dataset is your primary source of information). However, you can also use right_join(), inner_join(), or full_join() depending on your needs.\n\n\n\nFrom https://mikoontz.github.io/data-carpentry-week/lesson_joins.html\n\n\nWith our combined data, we can see how temperature anomaly compares to per-capita CO₂ emissions:\n\ndata_co2  |&gt; \n    left_join(\n        data_temp, \n        by = \"year\"\n    )  |&gt; \n    drop_na() |&gt;\n    ggplot(\n        aes(x = co2, \n            y = temp_anomaly)\n        ) +\n    geom_smooth(se = FALSE) +\n    geom_point(aes(color = year)) +\n    scale_color_viridis_c() +\n    labs(\n        x = \"Annual CO2 emissions per capita\",\n        y = \"Average temperature anomaly\"\n    ) +\n    jtools::theme_nice()\n\nleft_join: added one column (temp_anomaly)\n           &gt; rows only in data_co2   10\n           &gt; rows only in data_temp (91)\n           &gt; matched rows            84\n           &gt;                        ====\n           &gt; rows total              94\ndrop_na: removed 10 rows (11%), 84 rows remaining\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\nExercise\nWe will use the band_members dataset and band_instruments dataset to practice joining data. Take a look at the datasets first, and then check how the two ways of joining data give different results.\n\nExerciseSolution\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nlibrary(tidyverse)\n\nband_members  |&gt; \n   left_join(\n        band_instruments, \n        by = \"name\"\n   )\n\nleft_join: added one column (plays)\n           &gt; rows only in band_members      1\n           &gt; rows only in band_instruments (1)\n           &gt; matched rows                   2\n           &gt;                               ===\n           &gt; rows total                     3\n\n\n\n  \n\n\nband_instruments  |&gt;\n    left_join(\n          band_members, \n          by = \"name\"\n    )\n\nleft_join: added one column (band)\n           &gt; rows only in band_instruments  1\n           &gt; rows only in band_members     (1)\n           &gt; matched rows                   2\n           &gt;                               ===\n           &gt; rows total                     3\n\n\n\n  \n\n\n\nNotice that when we flip the order of the data frames in left_join(), the results change, because a left join always “favors” the data frame that comes first.",
    "crumbs": [
      "Data Wrangling",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Import and Join Data</span>"
    ]
  },
  {
    "objectID": "11_plot_amount.html",
    "href": "11_plot_amount.html",
    "title": "11  Visualizing Amount",
    "section": "",
    "text": "11.1 Bar plots\nVisualizing amounts is a foundational task in data analysis. This tutorial covers best practices, common tools, and key considerations for effective visualizations.\nBelow we start, as always, let us load the packages we need:\nHere we use the ggthemr package to style all the plots.\nBar plots are among the most straightforward ways to visualize the amount. We have all learnt it very early in school. They’re great when you have discrete categories—like species of penguins—and you want to compare their counts at a glance.\nTha task here is to visualize how many penguins belong to each species in the penguins dataset. Using what we have learned so far, we can do this in a few lines of code:\npenguins_count &lt;- penguins |&gt;\n1    group_by(species) |&gt;\n2    summarise(n = n()) |&gt;\n3    ungroup()\n\n\n1\n\nThis tells R to group the data by the species column.\n\n2\n\nThis tells R to count the number of rows in each group.\n\n3\n\nThis tells R to remove the grouping.\n\n\n\n\ngroup_by: one grouping variable (species)\nsummarise: now 3 rows and 2 columns, ungrouped\nungroup: no grouping variables remain\nWe use geom_bar(stat = \"identity\") with pre-aggregated data:\npenguins_count |&gt; \n    ggplot(aes(x = species, y = n)) +\n1    geom_bar(stat = \"identity\")\n\n\n1\n\nUses ‘n’ column for y-values.\nA very common mistake is to forget to add the stat = \"identity\" argument to the geom_bar() function. If you forget this argument, ggplot will automatically calculate the count of each category and plot it. While this may be useful in some cases, it is generally not recommended because it is not transparent.\nYou may think bar plot is so simple. Surprisingly, a recent study shows that almost one-third of biological papers use bar plots incorrectly. Thus, our job is not done yet. Below are a few techniques to make bar plots more informative and visually appealing.",
    "crumbs": [
      "Advanced Visualization",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Visualizing Amount</span>"
    ]
  },
  {
    "objectID": "11_plot_amount.html#bar-plots",
    "href": "11_plot_amount.html#bar-plots",
    "title": "11  Visualizing Amount",
    "section": "",
    "text": "11.1.1 Adding amount values\nIt is useful to add the amount of each category to the bar plot. We can do this by adding a geom_text() layer to the plot.\n\npenguins_count  |&gt; \n    ggplot(aes(x = species, y = n)) +\n    geom_bar(stat = \"identity\") +\n1    geom_text(aes(label = n), size = 5,vjust = -0.5) +\n2    coord_cartesian(clip = 'off')\n\n\n1\n\nMove the label up by 0.5 units.\n\n2\n\nAllow the text to be displayed outside the plot area.\n\n\n\n\n\n\n\n\n\n\n\nTwo important things to note here:\n\nThe vjust argument in geom_text() is used to adjust the vertical position of the text label.\nThe coord_cartesian(clip = 'off') function is used to ensure that the text label is not clipped when it extends beyond the plot area. This is an important trick to remember.\n\n\n\n11.1.2 Reordering bars\nIt is helpful to reorder the bars in a bar plot. We can do this by using the reorder() function.\n\npenguins_count |&gt; \n    ggplot(aes(\n1        x = reorder(species, n),\n        y = n\n    )) + \n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label = n), size = 5, vjust = -0.5) +\n    coord_cartesian(clip = 'off') \n\n\n1\n\nThis tells ggplot to reorder the bars by the n column.\n\n\n\n\n\n\n\n\n\n\n\nHowever, we do not always want to reorder the bars by the amount. For example, the categories are age distribution. When you want to reorder the bars by some manual order, you can use the fct_relevel() function.\n\npenguins_count |&gt; \n1    mutate(species = fct_relevel(species, \"Adelie\", \"Chinstrap\", \"Gentoo\")) |&gt;\n    ggplot(aes(x = species, y = n)) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label = n), size = 5, vjust = -0.5) +\n    coord_cartesian(clip = 'off') \n\n\n1\n\nThis tells R to reorder the species column by the order of “Adelie”, “Chinstrap”, “Gentoo”.\n\n\n\n\nmutate: no changes\n\n\n\n\n\n\n\n\n\n\n\n11.1.3 Highlight some categories\nFor example, we can highlight the “Adelie” category by changing its color to red:\n\npenguins_count |&gt; \n    ggplot(aes(x = species, y = n, fill = species)) +\n    geom_bar(data = filter(penguins_count, species == \"Adelie\"), \n        stat = \"identity\", fill = \"dodgerblue\") +\n    geom_bar(data = filter(penguins_count, species != \"Adelie\"), \n        stat = \"identity\", fill = \"grey\") +\n    geom_text(aes(label = n), size = 5, vjust = -0.5) +\n    coord_cartesian(clip = 'off') \n\n\n\n\n\n\n\n\n\n\n11.1.4 Differentiate bars\nWe sometimes want to differentiate the bars as much as possible. One obvious way is to use different colors for each bar:\n\npenguins_count |&gt; \n    ggplot(aes(x = species, y = n, fill = species)) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label = n), size = 5, vjust = -0.5) +\n    MetBrewer::scale_fill_met_d(\"Hiroshige\", direction=1)+\n    coord_cartesian(clip = 'off') \n\n\n\n\n\n\n\n\nHowever, colors are not the only way, especially when people may print the plot in black and white. One alternative is to use different patterns for each bar using the ggpattern package.\n\nlibrary(ggpattern)\n\npenguins_count |&gt; \n    ggplot(aes(x = species, y = n)) +\n    ggpattern::geom_col_pattern(\n        aes(pattern_fill = species, \n            pattern      = species), \n            fill  = 'white',\n            color = 'black'\n    ) +\n    geom_text(aes(label = n), size = 5, vjust = -0.5) +\n    coord_cartesian(clip = 'off') +\n    theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n11.1.5 Custom Themes\nSince the bars are vertical, we do not need the vertical grid lines. We can change the theme of the plot by using the theme() function. Always think about what elements are redundant and remove them.\n\npenguins_count |&gt; \n    ggplot(aes(\n        x = reorder(species, n),\n        y = n\n    )) + \n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label = n), size = 5, vjust = -0.5) +\n    coord_cartesian(clip = 'off') +\n    theme(\n        axis.line.x = element_line(colour = \"grey\", linewidth = 0.15), \n        panel.grid.major.x = element_blank(), \n        panel.grid.minor.x = element_blank(), \n        panel.grid.major.y = element_line(colour = \"grey\", linewidth = 0.15), \n        panel.grid.minor.y = element_blank(), \n        axis.ticks.x = element_line(colour = \"grey\", linewidth = 0.15), \n        axis.ticks.y = element_line(colour = \"grey\", linewidth = 0.15)\n    )",
    "crumbs": [
      "Advanced Visualization",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Visualizing Amount</span>"
    ]
  },
  {
    "objectID": "11_plot_amount.html#bar-plots-variations",
    "href": "11_plot_amount.html#bar-plots-variations",
    "title": "11  Visualizing Amount",
    "section": "11.2 Bar plots variations",
    "text": "11.2 Bar plots variations\n\n11.2.1 Horizontal bar plots\nWe can also create horizontal bar plots. This is useful when the category is a long string (you can rotate the x-axis text but it is bad for readability). It is easy to do this by changing the x and y axis:\n\npenguins_count |&gt; \n    ggplot(aes(y = reorder(species, n), x = n)) +\n    geom_bar(stat = \"identity\") +\n    geom_text(aes(label = n), hjust = -0.3) +\n    coord_cartesian(clip = 'off') +\n    theme(\n        axis.line.y = element_line(colour = \"grey\", linewidth = 0.15), \n        panel.grid.major.x = element_line(colour = \"grey\", linewidth = 0.15), \n        panel.grid.minor.x = element_blank(), \n        panel.grid.major.y = element_blank(), \n        panel.grid.minor.y = element_blank(), \n        axis.ticks.x = element_line(colour = \"grey\", linewidth = 0.15), \n        axis.ticks.y = element_line(colour = \"grey\", linewidth = 0.15)\n    )\n\n\n\n\n\n\n\n\nNotice that we have removed the horizontal (instead of vertical) grid lines because they are redundant now.\n\n\n11.2.2 Lollipop plots\nBar plots are not the only way to visualize the amount of different categories. A big issue with bar plots is that it has a low data-to-ink ratio (This is not a principle we have to follow always, but it is helpful to keep in mind). Dot plots are a (increasingly popular) alternative.\nWe can create a dot plot by adding a shrinked bar plot and then adding points to it:\n\npenguins_count |&gt; \n    ggplot(aes(y = reorder(species, n), x = n)) +\n    geom_bar(stat = \"identity\", width = 0.01) +\n    geom_point(size = 5) +\n    geom_text(aes(label = n), size = 5, vjust = -1) +\n    coord_cartesian(clip = 'off') +\n    theme(\n        axis.line.y = element_line(colour = \"grey\", linewidth = 0.15), \n        panel.grid.major.x = element_line(colour = \"grey\", linewidth = 0.15), \n        panel.grid.minor.x = element_blank(), \n        panel.grid.major.y = element_blank(), \n        panel.grid.minor.y = element_blank(), \n        axis.ticks.x = element_line(colour = \"grey\", linewidth = 0.15), \n        axis.ticks.y = element_line(colour = \"grey\", linewidth = 0.15)\n    ) \n\n\n\n\n\n\n\n\nYou can also use the geom_lollipop from the ggalt package to create lollipop plots.\n\n\n11.2.3 Circular bar plots\nAnother trendy way to visualize the amount of different categories is to use circular bar plots.\n\npenguins_count |&gt; \n    ggplot(\n        aes(x = reorder(species, n), \n            y = n, \n            color = species, \n            fill = species\n        )\n    ) +\n    geom_col(alpha = .5) +\n    scale_y_continuous(\n        limits = c(-50, 160)\n    ) + \n    geom_hline(yintercept = 50, color = \"grey\", linewidth = 0.15) +\n    geom_hline(yintercept = 100, color = \"grey\", linewidth = 0.15) +\n    geom_hline(yintercept = 150, color = \"grey\", linewidth = 0.15) +\n    geom_text(aes(label = species), position = position_stack(vjust = 0.5), color = 'white') +\n    coord_polar() +\n    theme_void() +\n    theme(\n        legend.position = \"none\"\n    )\n\n\n\n\n\n\n\n\n\n\n11.2.4 Waffle charts\nIt is also increasingly popular to use waffle charts to visualize the amount of different categories.\n\nlibrary(waffle)\n\nggplot(penguins_count, aes(fill=species, values=n)) +\n  geom_waffle(color = 'white') +\n  theme_void()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nParliament plots\n\n\n\n\n\n\nlibrary(ggpol)\n\npenguins_count |&gt;\n    ggplot() +\n    geom_parliament(aes(seats = n, fill = species), color = \"black\") + \n    scale_fill_manual(\n        values = MetBrewer::met.brewer(\"Isfahan2\", direction=1), \n        labels = c(\"Adelie\", \"Chinstrap\", \"Gentoo\")) +\n    theme_void()\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead.",
    "crumbs": [
      "Advanced Visualization",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Visualizing Amount</span>"
    ]
  },
  {
    "objectID": "11_plot_amount.html#multiple-categories",
    "href": "11_plot_amount.html#multiple-categories",
    "title": "11  Visualizing Amount",
    "section": "11.3 Multiple categories",
    "text": "11.3 Multiple categories\nHow about multiple types of categories? Suppose we want to visualize the amount of penguins of different species and sex. Let us first count the number of penguins of each species and sex:\n\npenguins_count_sex &lt;- penguins |&gt;\n    drop_na(sex) |&gt;\n    group_by(species, sex) |&gt;\n    summarise(n = n()) |&gt;\n    ungroup()\n\nThe most obvious way to visualize this is to use bar plots.\n\nStacked bar plotsSide by side bar plots\n\n\nStacked bar plots are a very common way to visualize the amount of different categories. However, they are hard to compare the trend of different categories.\n\npenguins_count_sex |&gt;\n    ggplot(aes(x = species, y = n, fill = sex)) +\n    geom_bar(stat = \"identity\") \n\n\n\n\n\n\n\n\nIn contrast, one potential solution is to remove the y axis and just add the amount of each category:\n\npenguins_count_sex |&gt;\n    ggplot(aes(x = species, y = n, fill = sex)) +\n    geom_bar(stat = \"identity\") +\n    geom_text(\n        aes(label = n), \n        color = 'white',\n        size = 5,\n        position = position_stack(vjust = 0.5)) +\n    theme(\n        axis.line.y = element_blank(), \n        panel.grid.major = element_blank(), \n        panel.grid.minor = element_blank(), \n        axis.ticks.y = element_blank(),\n        axis.text.y = element_blank(),\n        axis.title.y = element_blank()\n    )\n\n\n\n\n\n\n\n\n\n\nAn alternative to stacked bar plots is to plot the bars side by side. This is useful when you want to compare the trend within different categories.\n\npenguins_count_sex |&gt;\n    ggplot(aes(x = species, y = n, fill = sex)) +\n    geom_bar(stat = \"identity\", position = \"dodge\") \n\n\n\n\n\n\n\n\n\n\n\n\n11.3.1 Waffle charts\nYou can also use other types (geoms) as well. For example, waffle charts.\n\npenguins_count_sex |&gt;\n    ggplot(aes(values = n, fill = sex)) +\n    geom_waffle(color = \"white\", size = .25, n_rows = 10, flip = TRUE) +\n    facet_wrap(~species, nrow = 1, strip.position = \"bottom\") +\n    scale_x_discrete() +\n    MetBrewer::scale_fill_met_d(\"Hiroshige\", direction=1)\n\n\n\n\n\n\n\n\n\n\n11.3.2 Dumbell plots\nAnother useful alternative is to use the dumbell plot. It is quite similar to the lollipop plot. We will use the ggalt package to create the dumbell plot.\n\npenguins |&gt;\n    drop_na(sex) |&gt;\n    group_by(species, sex) |&gt;\n    summarise(mean_bill_length = mean(bill_length_mm, na.rm = TRUE)) |&gt;\n    ungroup() |&gt;\n    pivot_wider(names_from = sex, values_from = mean_bill_length) |&gt;\n    ggplot(aes(x = female, xend = male, y = species)) +\n    ggalt::geom_dumbbell(size=3, color=\"#e3e2e1\", \n                colour_x = \"#5b8124\", colour_xend = \"#bad744\",\n                dot_guide=TRUE, dot_guide_size=0.5) +\n    labs(x=NULL, y=NULL) +\n    hrbrthemes::theme_ipsum_rc(grid=\"X\")",
    "crumbs": [
      "Advanced Visualization",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Visualizing Amount</span>"
    ]
  },
  {
    "objectID": "12_plot_distribution.html",
    "href": "12_plot_distribution.html",
    "title": "12  Visualizing Distribution",
    "section": "",
    "text": "12.1 Single Variable\nData distributions are central to data analysis. We’ll explore several methods for visualizing distributions in R using ggplot2 and related packages.\nLet us begin by loading the necessary packages and setting the theme.",
    "crumbs": [
      "Advanced Visualization",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Visualizing Distribution</span>"
    ]
  },
  {
    "objectID": "12_plot_distribution.html#single-variable",
    "href": "12_plot_distribution.html#single-variable",
    "title": "12  Visualizing Distribution",
    "section": "",
    "text": "12.1.1 Histograms\nHistograms are a common way to visualize the distribution of a single variable. In this example, we plot the distribution of flipper_length_mm from the penguins dataset:\n\npenguins |&gt;\n    ggplot(aes(x = flipper_length_mm)) +\n    geom_histogram(color = \"white\")\n\n\n\n\n\n\n\n\nA frequent mistake is to call geom_histogram() without specifying the binwidth. When you don’t set the bin width, ggplot2 uses a default value that may not reveal important details in your data. The example below shows how changing the bin width affects the histogram:\n\n\n\n\n\n\n\n\n\n\n\n12.1.2 Density Plots\nDensity plots provide a smooth estimate of the distribution. For example, the following code creates a density plot for flipper_length_mm:\n\npenguins |&gt;\n    ggplot(aes(x = flipper_length_mm)) +\n    geom_density(fill = \"lightblue\")\n\n\n\n\n\n\n\n\nA common pitfall is that the density curve may extend beyond the actual data range. To illustrate, if you normalize your data to range from 0 to 1, the density estimate might still spill outside these bounds. Consider the following example where we normalize the flipper lengths and then set explicit x-axis limits:\n\npenguins |&gt;\n    drop_na(flipper_length_mm) |&gt;\n    mutate(flipper_length_mm_normalized = (flipper_length_mm - min(flipper_length_mm)) / (max(flipper_length_mm) - min(flipper_length_mm))) |&gt;\n    ggplot(aes(x = flipper_length_mm_normalized)) +\n    geom_density(fill = \"lightblue\") +\n1    xlim(-.2, 1.2)\n\n\n1\n\nWe set the x-axis limits to [-0.2, 1.2] to illustrate the issue.\n\n\n\n\n\n\n\n\n\n\n\nWithout careful inspection, you might not notice that the density extends outside the [0, 1] interval. To fix this, you can specify the bounds in geom_density():\n\npenguins |&gt;\n    drop_na(flipper_length_mm) |&gt;\n    mutate(flipper_length_mm_normalized = (flipper_length_mm - min(flipper_length_mm)) / (max(flipper_length_mm) - min(flipper_length_mm))) |&gt;\n    ggplot(aes(x = flipper_length_mm_normalized)) +\n    geom_density(fill = \"lightblue\", \n1                bounds = c(0, 1)) +\n    xlim(-.2, 1.2)\n\n\n1\n\nWe specify the bounds in geom_density() to ensure the density curve stays within the [0, 1] interval.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAlternative density estimate\n\n\n\n\n\nThe ggalt package’s geom_bkde() function can sometimes provide a better density estimate.",
    "crumbs": [
      "Advanced Visualization",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Visualizing Distribution</span>"
    ]
  },
  {
    "objectID": "12_plot_distribution.html#comparing-more-than-one-variable",
    "href": "12_plot_distribution.html#comparing-more-than-one-variable",
    "title": "12  Visualizing Distribution",
    "section": "12.2 Comparing More Than One Variable",
    "text": "12.2 Comparing More Than One Variable\n\n12.2.1 Histograms vs Density\nAs a general rule, DON’T use Histograms naively when dealing with multiple variables. For example, all three examples below are difficult to efficiently compare the distribution of flipper length across different species.\n\nOverlapping histogramsStacked HistogramsSide by side histograms\n\n\nEach group is plotted in the same space with transparency:\n\npenguins |&gt; \n    ggplot(aes(x = flipper_length_mm, group = species, fill = species)) +\n    geom_histogram(color = \"white\", alpha = .5,position = \"identity\") +\n    theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n\n\nHistograms are stacked on top of each other to compare proportions:\n\npenguins |&gt;\n    ggplot(aes(x = flipper_length_mm, group = species, fill = species)) +\n    geom_histogram(color = \"white\", position = \"stack\") +\n    theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n\n\nHistograms for each group are placed next to one another for easier comparison:\n\npenguins |&gt; \n    ggplot(aes(x = flipper_length_mm, group = species, fill = species)) +\n    geom_histogram(color = \"white\", position = \"dodge\") +\n    theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\n\n\n\nDensity plots are generally easier to compare when multiple groups are involved. The following code overlays density curves for each species:\n\npenguins |&gt; \n    ggplot(aes(\n        x = flipper_length_mm, \n        group = species, \n        fill = species, \n        color = species)) +\n    geom_density(alpha = .5) +\n    theme(legend.position = \"top\")\n\n\n\n\n\n\n\n\nAs we mentioned before, it is generally a good idea to avoid using legends. The library geomtextpath provides a way to add text to the density plot.\n\nlibrary(geomtextpath)\n\npenguins |&gt; \n    ggplot(aes(x = flipper_length_mm, group = species, color = species)) +\n    geom_textdensity(alpha = .5, aes(label = species), size = 5) +\n    theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n12.2.2 Better Variations for Group Comparisons\nThere are many variations of density/histogram plots that are more informative and aesthetically pleasing. I particularly like two of them.\n\nSeparated plotsMirror density\n\n\nFor datasets with more than two groups, faceting and highlighting each group can be very effective. We can easily do this with the gghighlight package:\n\nlibrary(gghighlight)\n\npenguins |&gt; \n    ggplot(aes(x = flipper_length_mm, fill = species)) +\n    geom_histogram(color = \"white\") +\n    gghighlight() +\n    facet_wrap(~species)\n\n\n\n\n\n\n\n\n\n\nWhen comparing two groups, a mirror density plot places one density curve above and one below the horizontal axis. This example compares male and female penguins:\n\npenguins |&gt; \n    ggplot(aes(x = flipper_length_mm)) +\n    geom_density(\n        data = filter(penguins, sex == \"male\"),\n        aes(y = ..density..),\n        alpha = .5, fill = \"#69b3a2\", color = \"black\") +\n    geom_label( aes(x=180, y=0.02, label=\"male\"), color=\"#69b3a2\", size = 5) +\n    geom_density(\n        data = filter(penguins, sex == \"female\"),\n        aes(y = -..density..),\n        alpha = .5, fill = \"#404080\", color = \"black\") +\n    geom_label( aes(x=228, y=-0.01, label=\"female\"), color=\"#404080\", size = 5)",
    "crumbs": [
      "Advanced Visualization",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Visualizing Distribution</span>"
    ]
  },
  {
    "objectID": "12_plot_distribution.html#many-distributions-at-once",
    "href": "12_plot_distribution.html#many-distributions-at-once",
    "title": "12  Visualizing Distribution",
    "section": "12.3 Many distributions at once",
    "text": "12.3 Many distributions at once\nSometimes, you need to display distributions for many groups simultaneously. For example, we use the lincoln_weather dataset (from the ggridges package) to demonstrate different approaches.\nWe first clean the data by selecting relevant columns and extracting the month from the date:\n\nlibrary(ggridges)\n\nWarning: package 'ggridges' was built under R version 4.2.3\n\nlincoln_weather_clean &lt;- lincoln_weather |&gt;\n    select(CST, `Mean Temperature [F]`) |&gt;\n    mutate(CST = ymd(CST)) |&gt;\n    mutate(month = month(CST, label = TRUE))\n\nselect: dropped 22 variables (Max Temperature [F], Min Temperature [F], Max Dew Point [F], Mean Dew Point [F], Min Dewpoint [F], …)\nmutate: converted 'CST' from character to Date (0 new NA)\nmutate: new variable 'month' (ordered factor) with 12 unique values and 0% NA\n\nlincoln_weather_clean\n\n\n  \n\n\n\n\n12.3.1 Summarizing with Points and Error Bars\nOne approach is to show the mean along with an error bar. Always be explicit about how you compute the error bar!\n\nConfidence limitStandard deviationStandard error\n\n\n\nlincoln_weather_clean |&gt;\n    group_by(month) |&gt;\n    summarise(mean = mean(`Mean Temperature [F]`),\n              lower = quantile(`Mean Temperature [F]`, 0.025),\n              upper = quantile(`Mean Temperature [F]`, 0.975)) |&gt;\n    ggplot(aes(x = month, y = mean, ymin = lower, ymax = upper)) +\n    geom_pointrange()\n\ngroup_by: one grouping variable (month)\nsummarise: now 12 rows and 4 columns, ungrouped\n\n\n\n\n\n\n\n\n\n\n\n\nlincoln_weather_clean |&gt;\n    group_by(month) |&gt;\n    summarise(mean = mean(`Mean Temperature [F]`),\n              sd = sd(`Mean Temperature [F]`)) |&gt;\n    ggplot(aes(x = month, y = mean)) +\n    geom_pointrange(aes(ymin = mean - sd, ymax = mean + sd))\n\ngroup_by: one grouping variable (month)\nsummarise: now 12 rows and 3 columns, ungrouped\n\n\n\n\n\n\n\n\n\n\n\n\nlincoln_weather_clean |&gt;\n    group_by(month) |&gt;\n    summarise(mean = mean(`Mean Temperature [F]`),\n              se = sd(`Mean Temperature [F]`) / sqrt(n())) |&gt;\n    ggplot(aes(x = month, y = mean)) +\n    geom_pointrange(aes(ymin = mean - se, ymax = mean + se))\n\ngroup_by: one grouping variable (month)\nsummarise: now 12 rows and 3 columns, ungrouped\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n12.3.2 Showing the Full Distribution\nWhenever possible, display the full distribution rather than just summary statistics.\n\nBoxplotViolin Plot\n\n\n\nlincoln_weather_clean |&gt; \n    ggplot(aes(x = month, y = `Mean Temperature [F]`)) +\n    geom_boxplot() \n\n\n\n\n\n\n\n\n\n\n\nlincoln_weather_clean |&gt; \n    ggplot(aes(x = month, y = `Mean Temperature [F]`)) +\n    geom_violin() \n\n\n\n\n\n\n\n\n\n\n\nIt is generally advised to use violin plots instead of boxplots, especially when the data is not normally distributed (which is often the case). The animated comparison below illustrates why violin plots often convey more information than boxplots.\n\n\n\nFrom https://www.research.autodesk.com/publications/same-stats-different-graphs/\n\n\n\n\n12.3.3 Plotting the Actual Data Points\nIt’s a good idea to show the raw data along with any summaries. This is especially true for real data, where we often have to work with limited samples. It is less useful, or sometimes even advised against, for synthetic data.\n\nDON’t just use geom_point()Jittered pointsBeeswarm style\n\n\n\nlincoln_weather_clean |&gt; \n    ggplot(aes(x = month, y = `Mean Temperature [F]`)) +\n    geom_point(alpha = .5)\n\n\n\n\n\n\n\n\n\n\nJittering helps avoid overlapping points:\n\nlincoln_weather_clean |&gt; \n    ggplot(aes(x = month, y = `Mean Temperature [F]`)) +\n    geom_jitter(alpha = .5)\n\n\n\n\n\n\n\n\n\n\nFor more controlled jittering, use the ggbeeswarm package:\n\nlincoln_weather_clean |&gt; \n    ggplot(aes(x = month, y = `Mean Temperature [F]`)) +\n    ggbeeswarm::geom_quasirandom(varwidth = TRUE) \n\n\n\n\n\n\n\n\n\n\n\nEven better, why not show both the data and the distribution?\n\nSina plotHalf-half plot\n\n\n\nlincoln_weather_clean |&gt; \n    ggplot(aes(x = month, y = `Mean Temperature [F]`)) +\n    geom_violin(alpha = .5) +\n    ggforce::geom_sina()\n\n\n\n\n\n\n\n\n\n\n\nlincoln_weather_clean |&gt; \n    ggplot(aes(x = month, y = `Mean Temperature [F]`)) +\n    gghalves::geom_half_violin(alpha = .5) +\n    gghalves::geom_half_dotplot(method=\"histodot\", stackdir=\"up\", binwidth = 1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n12.3.4 Ridge plot\nRidge plots (also known as joy plots) are great for comparing the distribution of a variable across many groups in a compact format. It provides a horizontal axis and a vertical density plot for each group.\n\nlibrary(ggridges)\nlincoln_weather_clean |&gt; \n    ggplot(aes(\n        x = `Mean Temperature [F]`, \n        y = month, \n        fill = month, \n        color = month\n    )) +\n    geom_density_ridges(alpha = .5) +\n    theme_ridges() +\n    theme(legend.position = \"none\") \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHorizontal Plots\n\n\n\n\n\nHorizon plots are an effective way to visualize time series data. It is extremely useful when you need to compare even more variables. You can use the ggHoriPlot package to create them. Check out the documentation here for stunning examples.",
    "crumbs": [
      "Advanced Visualization",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Visualizing Distribution</span>"
    ]
  },
  {
    "objectID": "13_plot_trend.html",
    "href": "13_plot_trend.html",
    "title": "13  Visualizing Trends",
    "section": "",
    "text": "13.1 The Most Simple Case: A Basic Trend Plot\nTrends are another most common type of plot. They are used to show how a variable changes over time (or any other variable of interest).\nWe load the same packages as before.\nLet’s start with a simple example using the economics dataset from the tidyverse. To simplify the example, we’ll filter the data to include only observations after the year 2000 and further restrict it to January data.\neconomics |&gt;\n1    filter(year(date) &gt; 2000) |&gt;\n2    filter(month(date) == 1) |&gt;\n    ggplot(aes(x = date, y = unemploy)) +\n    geom_point(color = \"white\", fill = \"#0072B2\", shape = 21, size = 2)\n\n\n1\n\nFilter the data to only include data after the year 2000.\n\n2\n\nFilter the data to only include data for the first month of each year.\n\n\n\n\nfilter: removed 402 rows (70%), 172 rows remaining\nfilter: removed 157 rows (91%), 15 rows remaining\nThe figure above is not very informative. It is difficult to see the trend. Below are some tweaks that can help.",
    "crumbs": [
      "Advanced Visualization",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Visualizing Trends</span>"
    ]
  },
  {
    "objectID": "13_plot_trend.html#the-most-simple-case-a-basic-trend-plot",
    "href": "13_plot_trend.html#the-most-simple-case-a-basic-trend-plot",
    "title": "13  Visualizing Trends",
    "section": "",
    "text": "Connect the pointsUsing a SplineArea Plot\n\n\nConnect the dots with a line to reveal the trend. This is easy to do with geom_line().\n\neconomics |&gt;\n    filter(year(date) &gt; 2000) |&gt;\n    filter(month(date) == 1) |&gt;\n    ggplot(aes(x = date, y = unemploy)) +\n    geom_line(linewidth = 1, color = \"#0072B2\") +\n    geom_point(color = \"white\", fill = \"#0072B2\", shape = 21, size = 4)\n\nfilter: removed 402 rows (70%), 172 rows remaining\nfilter: removed 157 rows (91%), 15 rows remaining\n\n\n\n\n\n\n\n\n\nA useful tip is to color the border of the points white, so they stand out better against the line.\n\n\nSometimes a smooth curve is easier on the eyes. We can use the geom geom_xspline() from the ggalt package to create a spline to connect all the points.\n\neconomics |&gt;\n    filter(year(date) &gt; 2000) |&gt;    \n    filter(month(date) == 1) |&gt;\n    ggplot(aes(x = date, y = unemploy)) +\n    ggalt::geom_xspline(color = \"#0072B2\") +\n    geom_point(color = \"white\", fill = \"#0072B2\", shape = 21, size = 4)\n\n\n\n\n\n\n\n\n\n\nAn area plot is a great way to show the trend of a variable over time. It is a line plot with a shaded area under the line. We can use geom_area() to create an area plot.\n\neconomics |&gt;\n    filter(year(date) &gt; 2000) |&gt;\n    filter(month(date) == 1) |&gt;\n    ggplot(aes(x = date, y = unemploy)) +\n    geom_line(linewidth = 1, color = \"#0072B2\") +\n    geom_point(color = \"white\", fill = \"#0072B2\", shape = 21, size = 4) +\n    geom_area(fill = \"#0072B2\", alpha = 0.2)\n\nfilter: removed 402 rows (70%), 172 rows remaining\nfilter: removed 157 rows (91%), 15 rows remaining",
    "crumbs": [
      "Advanced Visualization",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Visualizing Trends</span>"
    ]
  },
  {
    "objectID": "13_plot_trend.html#dealing-with-many-points",
    "href": "13_plot_trend.html#dealing-with-many-points",
    "title": "13  Visualizing Trends",
    "section": "13.2 Dealing with Many Points",
    "text": "13.2 Dealing with Many Points\nWhen there are many data points, plotting each one might make your graph look like a plate of spaghetti—delicious, but messy!\n\neconomics |&gt;\n    filter(year(date) &gt; 2000) |&gt;    \n    ggplot(aes(x = date, y = unemploy)) +\n    geom_line(color = \"#0072B2\") +\n    geom_point(color = \"white\", fill = \"#0072B2\", shape = 21, size = 3)\n\n\n\n\n\n\n\n\nIn these cases, smoothing the data can help you see the overall trend more clearly. Below are some alternatives to consider.\n\n13.2.1 Moving average\nA moving average smooths out short-term fluctuations, giving you a clearer view of the long-term trend. It’s like averaging your favorite TV show ratings over several episodes rather than judging based on one controversial finale.\nWe can use the zoo package to calculate the moving average.\n\neconomics |&gt;\n    filter(year(date) &gt; 2000) |&gt;\n1    mutate(unemploy_avg_year = zoo::rollmean(unemploy, k = 12, fill = NA)) |&gt;\n2    mutate(unemploy_avg_2years = zoo::rollmean(unemploy, k = 24, fill = NA)) |&gt;\n    ggplot(aes(x = date, y = unemploy)) +\n    geom_line(aes(color = 'line')) +\n3    geom_line(aes(y = unemploy_avg_year, color = 'year'), size = 1) +\n4    geom_line(aes(y = unemploy_avg_2years, color = '2 years'), size = 1) +\n5    scale_color_manual(\n      values = c(`line` = \"grey60\", `year` = \"#d55e00\", `2 years` = \"#009E73\"),\n      breaks = c(\"year\", \"2 years\", \"line\"),\n      labels = c(\"Yearly average\", \"2-year average\", \"Line\"),\n      name = NULL\n    ) + \n    theme(legend.position = 'top')\n\n\n1\n\nCalculate the moving average for the last 12 months.\n\n2\n\nCalculate the moving average for the last 24 months.\n\n3\n\nAdd the moving average for the last 12 months to the plot.\n\n4\n\nAdd the moving average for the last 24 months to the plot.\n\n5\n\nCustomize the color legend.\n\n\n\n\n\n\n\n\n\n\n\n\n\n13.2.2 Regression smoother\nAlternatively, you can add a regression smoother to highlight the trend. We have already used the linear regression smoother with geom_smooth(method = \"lm) in Chapter 6. It is easy to use other nonlinear methods.\n\neconomics |&gt;\n    filter(year(date) &gt; 2000) |&gt;    \n    ggplot(aes(x = date, y = unemploy)) +\n    geom_point(color = \"white\", fill = \"grey60\", shape = 21, size = 3) +\n1    geom_smooth(method = \"gam\", formula = y ~ s(x, k = 20, bs = 'cr'))\n\n\n1\n\nUse a generalized additive model (GAM) with a high-degree regression spline.\n\n\n\n\n\n\n\n\n\n\n\nIt is important to note that the smooth line depends heavily on the method used! When possible, it is a good idea to specify the method (like what we did above).\nAdditionally, when handling many data points, consider preprocessing or smoothing your data with packages like tidymodels—it can be much faster than forcing ggplot2 to do all the heavy lifting.",
    "crumbs": [
      "Advanced Visualization",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Visualizing Trends</span>"
    ]
  },
  {
    "objectID": "13_plot_trend.html#visualizing-trends-in-multiple-groups",
    "href": "13_plot_trend.html#visualizing-trends-in-multiple-groups",
    "title": "13  Visualizing Trends",
    "section": "13.3 Visualizing Trends in Multiple Groups",
    "text": "13.3 Visualizing Trends in Multiple Groups\nSo far, we’ve looked at trends for a single variable. But what if you want to visualize trends for multiple groups? For that, we’ll use the blockbusters dataset from the ggstream package.\nFirst, let’s load the data and quickly plot it.\n\n# install.packages(\"ggstream\")\n1data(\"blockbusters\", package = \"ggstream\")\n\nblockbusters |&gt; \n    ggplot(aes(x = year, y = box_office, color = genre)) +\n    geom_line()\n\n\n1\n\nLoad the data from the package\n\n\n\n\n\n\n\n\n\n\n\nThis figure is not informative, as we have too many lines. This is known as the (infamous) spaghetti graph. Below we will show some alternatives that are much more informative.\n\nFacetingStacked areaStreamgraphsBump plotDON‘T go 3D\n\n\nWe can also use facets to show the trend of each group.\n\nblockbusters |&gt; \n    ggplot(aes(x = year, y = box_office, color = genre)) +\n    geom_line(linewidth = .5) +\n    facet_wrap(~genre) +\n    MetBrewer::scale_color_met_d(\"Cross\") +\n    theme(legend.position = 'none')\n\n\n\n\n\n\n\n\nHowever, this ignored the comparison between the groups. We can use gghighlight to make the comparison more explicit.\n\nlibrary(gghighlight)\nblockbusters |&gt; \n    ggplot(aes(x = year, y = box_office, color = genre)) +\n    geom_line(linewidth = .5) +\n    gghighlight(use_direct_label = FALSE,\n                unhighlighted_params = list(colour = alpha(\"grey85\", 1))) +\n    facet_wrap(~genre) +\n    MetBrewer::scale_color_met_d(\"Cross\") +\n    theme(legend.position = 'none')\n\n\n\n\n\n\n\n\n\n\nA stacked area plot shows the contribution of each genre over time. Think of it as a layered cake.\n\nblockbusters |&gt; \n    ggplot(aes(x = year, y = box_office, fill = genre)) +\n    geom_area() +\n    MetBrewer::scale_fill_met_d(\"Cross\")\n\n\n\n\n\n\n\n\nHowever, a downside of stacked area is that it does not treat the groups equally. We can see the lowest group clearly, but the others are harder to see.\nOne special case when stacked area works well is when we only have two groups.\n\nblockbusters |&gt; \n    filter(genre %in% c(\"Comedy\", \"Drama\")) |&gt;\n    pivot_wider(names_from = genre, values_from = box_office) |&gt;\n    drop_na() |&gt;\n    ggplot(aes(x = year)) +\n    geom_line(aes(y = Comedy, color = \"Comedy\"), linewidth = 1) +\n    geom_line(aes(y = Drama, color = \"Drama\"), linewidth = 1) +\n    ggh4x::stat_difference(aes(ymin = Comedy, ymax = Drama), alpha = 0.3) +\n    scale_fill_manual(labels = c(\"More Comedy\", \"More Drama\"),\n                      values = c(\"#3D85F7\", \"#C32E5A\")) \n\nfilter: removed 103 rows (66%), 54 rows remaining\npivot_wider: reorganized (genre, box_office) into (Comedy, Drama) [was 54x3, now 32x3]\ndrop_na: removed 10 rows (31%), 22 rows remaining\n\n\n\n\n\n\n\n\n\n\n\nStreamgraphs are a visually appealing alternative that gives your plot a flowing, organic look. We can use the ggstream package to create them easily.\n\nblockbusters |&gt; \n    ggplot(aes(x = year, y = box_office, fill = genre)) +\n    ggstream::geom_stream(color = 'white') +\n    MetBrewer::scale_fill_met_d(\"Cross\")\n\n\n\n\n\n\n\n\n\n\nBump charts are more resticted in usage, but when used well, they are stunning. They are ideal for highlighting rankings (not amounts) over time, and when you have just a few groups.\n\nblockbusters |&gt; \n    filter(year %in% c(2000, 2002, 2004)) |&gt;\n    group_by(year) |&gt;\n    mutate(rank = rank(box_office)) |&gt;\n    ggplot(aes(x = year, y = rank, color = genre)) +\n    ggbump::geom_bump(size = 2, smooth = 6) +\n    geom_point(color = \"white\", size = 4) +\n    geom_point(size = 2) +\n    ggrepel::geom_label_repel(data = . %&gt;% filter(year == 2004), aes(label = genre), \n                             size = 4, nudge_x = 0.3) +\n    MetBrewer::scale_color_met_d(\"Cross\") +\n    scale_x_continuous(breaks = c(2000, 2002, 2004)) +\n    theme_minimal() +\n    theme(legend.position = 'none',\n          panel.grid = element_blank()\n    ) \n\nfilter: removed 142 rows (90%), 15 rows remaining\ngroup_by: one grouping variable (year)\nmutate (grouped): new variable 'rank' (double) with 5 unique values and 0% NA\nfilter (grouped): removed 10 rows (67%), 5 rows remaining (removed 2 groups, one group remaining)\n\n\n\n\n\n\n\n\n\n\n\nSome people like to use 3D plots to show trends. I admit that it is fancy, but it is generally not informative.\n\nlibrary(plotly)\n\nblockbusters |&gt;\nplot_ly(x = ~year,\n        y = ~genre,\n        z = ~box_office,\n        type = 'scatter3d',\n        mode = 'lines',\n        color = ~genre)",
    "crumbs": [
      "Advanced Visualization",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Visualizing Trends</span>"
    ]
  },
  {
    "objectID": "14_plot_association.html",
    "href": "14_plot_association.html",
    "title": "14  Visualizing Association",
    "section": "",
    "text": "14.1 Marginal distributions\nUnderstanding how variables are associated is one of the most important aspects of data analysis. We have already seen some examples of association in the previous chapters. But given its importance, we will greatly expand on this topic. In this chapter, we will explore a variety of techniques to visualize these associations.\nMarginal distributions show the distribution of each variable along the axes of a scatter plot. They provide additional context to understand the spread and density of the data.\nA simple way to add marginal information is by using geom_rug(), which adds tick marks along the axes:\npenguins |&gt;\n    ggplot(aes(x = bill_length_mm, y = bill_depth_mm)) +\n    geom_point() +\n    geom_rug()\n\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\nDespite its usefulness, when we have multiple groups, it would be difficult to differentiate the marginal distributions among groups.\nFor a clearer separation of marginal distributions by group, the ggside package provides density plots along each axis:\nlibrary(ggside)\n\n\n1\n\nAdd density plot along the x-axis\n\n2\n\nAdd density plot along the y-axis\n\n3\n\nRemove side axis text\n\n\n\n\nRegistered S3 method overwritten by 'ggside':\n  method from   \n  +.gg   ggplot2\n\npenguins |&gt;\n    ggplot(aes(x = bill_length_mm, y = bill_depth_mm, color = species)) +\n    geom_point() +\n1    geom_xsidedensity(aes(y = after_stat(density))) +\n2    geom_ysidedensity(aes(x = after_stat(density))) +\n    theme(\n3        ggside.axis.text = element_blank()\n    )",
    "crumbs": [
      "Advanced Visualization",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Visualizing Association</span>"
    ]
  },
  {
    "objectID": "14_plot_association.html#addressing-overplotting",
    "href": "14_plot_association.html#addressing-overplotting",
    "title": "14  Visualizing Association",
    "section": "14.2 Addressing Overplotting",
    "text": "14.2 Addressing Overplotting\nWhen there are too many points in a scatter plot, overplotting can obscure patterns and lead to misinterpretation (a related real science story here).\nWe will use the lending_club dataset from the modeldata package to illustrate several strategies for managing overplotting. We fist load and transform the data so that variables spanning several orders of magnitude are easier to visualize (using a log10() transformation):\n\ndata(lending_club, package = \"modeldata\")\n\nlending_club_log10 &lt;- lending_club |&gt;\n    mutate(annual_inc = log10(annual_inc)) |&gt;\n    mutate(total_il_high_credit_limit = log10(total_il_high_credit_limit)) |&gt;\n    filter(is.finite(annual_inc), is.finite(total_il_high_credit_limit))\n\nlending_club_log10 |&gt;\n    ggplot(aes(x = annual_inc, y = total_il_high_credit_limit)) +\n    geom_point()\n\n\n\n\n\n\n\n\n\nLowering Point Transparency2D Counter Plots with Density EstimationColor-Coding Points by Density\n\n\nBy reducing the transparency (alpha) of points, overlapping points become less dominant:\n\nlending_club_log10 |&gt;\n    ggplot(aes(x = annual_inc, y = total_il_high_credit_limit)) +\n1    geom_point(alpha = 0.05)\n\n\n1\n\nTune the transparency\n\n\n\n\n\n\n\n\n\n\n\nFor example, alpha = 0.05 means that 20 overlapping points are equivalent to 1 opaque point.\n\n\nInstead of plotting every individual point, you can visualize the density of points using counter plots. We will use the ggdensity package to help with this.\n\nlending_club_log10 |&gt;\n    ggplot(aes(x = annual_inc, y = total_il_high_credit_limit)) +\n1    ggdensity::geom_hdr()\n\n\n1\n\nAdd a 2D counter plot\n\n\n\n\n\n\n\n\n\n\n\nAlternatively, you can overlay density contours on top of a scatter plot:\n\nlending_club_log10 |&gt;\n    ggplot(aes(x = annual_inc, y = total_il_high_credit_limit)) +\n1    ggdensity::geom_hdr_lines() +\n2    geom_point(pch='.', color = 'black', size = 0.5, alpha = 0.05)\n\n\n1\n\nAdd density contours only\n\n2\n\nAdd points with low transparency\n\n\n\n\n\n\n\n\n\n\n\nNote that we used pch='.'. This makes data points as non-aliased single pixels. It greatly speed up rendering (which could take forever if you have a lot of points).\n\n\n\n\n\n\nWant it even faster?\n\n\n\nThe package scattermore (link) provides an insanely fast way to render scatter plots. For most use cases, it won’t matter that much, but it is always good to know you have options.\n\n\n\n\nThe ggpointdensity package colors points based on the local point density, highlighting areas of high concentration. It is a combination of two best worlds.\n\nlending_club_log10 |&gt;\n    ggplot(aes(x = annual_inc, y = total_il_high_credit_limit)) +\n    ggpointdensity::geom_pointdensity() +\n1    scale_color_viridis_c()\n\n\n1\n\nUse viridis color palette (generally preferred over the default)",
    "crumbs": [
      "Advanced Visualization",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Visualizing Association</span>"
    ]
  },
  {
    "objectID": "14_plot_association.html#axis-transformation",
    "href": "14_plot_association.html#axis-transformation",
    "title": "14  Visualizing Association",
    "section": "14.3 Axis Transformation",
    "text": "14.3 Axis Transformation\nBecause data can span several orders of magnitude, we often use log transformed axes. It is straightforward to do so in ggplot2. We will test the famous Kleiber’s law on how metabolic rate scales with body mass. We use the ex0826 dataset from the Sleuth3 package.\n\ndata(ex0826, package = \"Sleuth3\")\n\nex0826 |&gt;\n    ggplot(aes(x = Mass, y = Metab)) +\n    geom_point() +\n    scale_x_log10( \n        breaks = scales::trans_breaks(\"log10\", function(x) 10^x),\n        labels = scales::trans_format(\"log10\", scales::math_format(10^.x))\n    ) +\n    scale_y_log10(\n        breaks = scales::trans_breaks(\"log10\", function(x) 10^x),\n        labels = scales::trans_format(\"log10\", scales::math_format(10^.x))\n    ) +\n    annotation_logticks() +\n    geom_smooth(method = \"lm\") +\n    ggpmisc::stat_quant_eq()\n\n\n\n\n\n\n\n\nLog plots are super useful. However, it warrants caution as it may not be as intuitive as it seems (see a recent study).\nAdditionally, visual associations cannot replace rigorous statistical tests. As scientists, we should always put ourselves to a high standard to avoid artefacts (see two related scientific debates here and here).",
    "crumbs": [
      "Advanced Visualization",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Visualizing Association</span>"
    ]
  },
  {
    "objectID": "14_plot_association.html#high-dimensional-data",
    "href": "14_plot_association.html#high-dimensional-data",
    "title": "14  Visualizing Association",
    "section": "14.4 High-Dimensional Data",
    "text": "14.4 High-Dimensional Data\nWhen dealing with multiple variables, it is often insightful to explore relationships beyond simple 2D plots. We illustrate two common approaches with the penguins dataset.\n\npenguins_small &lt;- penguins |&gt;\n    select(species, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g) |&gt;\n    drop_na()\n\nselect: dropped 3 variables (island, sex, year)\ndrop_na: removed 2 rows (1%), 342 rows remaining\n\n\n\n14.4.1 Pairwise plots\nPairwise plots (or scatterplot matrices) allow you to visualize the relationships between all pairs of variables in a dataset. They are especially useful for exploratory data analysis. We will use the GGally package to create these plots.\n\npenguins_small |&gt;\n    GGally::ggpairs()\n\n\n\n\n\n\n\n\n\n\n14.4.2 Dimension reduction\nDimension reduction techniques help summarize high-dimensional data into two or three dimensions, making it easier to visualize complex relationships. Although many packages exist, we will use the ggpca package as it offers several options (e.g., PCA, t-SNE, UMAP) through a consistent interface.\n\nlibrary(ggpca)\npenguins_small |&gt;\n    ggpca(\n1        metadata_cols = \"species\",\n2        mode = \"pca\",\n3        color_var = \"species\",\n4        ellipse = TRUE\n    )\n\n\n1\n\nColumn to use for grouping/metadata\n\n2\n\nChoose PCA; change to “tsne” or “umap” as desired\n\n3\n\nColor points by species\n\n4\n\nAdd ellipses for group boundaries\n\n\n\n\n\n\n\n\n\n\n\nWhile dimension reduction techniques are powerful, they can sometimes be misleading. They simplify complex relationships and might hide important nuances of the data. For more insights on potential pitfalls, see this article.",
    "crumbs": [
      "Advanced Visualization",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Visualizing Association</span>"
    ]
  }
]