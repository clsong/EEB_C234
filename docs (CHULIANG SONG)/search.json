[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EE BIOL C234",
    "section": "",
    "text": "Weclome\nWelcome to EE BIOL C234: Practical Computing for Evolutionary Biologists and Ecologists—or, as I like to say, a crash course in “computational Kung-Fu”.",
    "crumbs": [
      "Weclome"
    ]
  },
  {
    "objectID": "index.html#course-info",
    "href": "index.html#course-info",
    "title": "EE BIOL C234",
    "section": "Course Info",
    "text": "Course Info\n\nWhere and When: We’ll be meeting Mondays and Wednesdays, 11:00 AM to 11:50 AM, in Botany 108.\nThe Grind: Yes, there will be weekly assignments. If you want to build computational muscle, you’re going to have to sweat a bit. But rest easy, no terrifying final exam to ruin your holidays!\nWhat to Bring: Just your laptop and a healthy dose of intellectual curiosity. If you have played with R before, great; if not, don’t worry—you’ll pick it up.\nCourse Material: This lecture note will be updated as the course progresses. \n\nThis is the inaugural run of this course for me. So if I’m losing you, boring you, talking too fast, too slow, whatever – speak up! Your feedback is my compass.",
    "crumbs": [
      "Weclome"
    ]
  },
  {
    "objectID": "index.html#how-to-use-the-lecture-notes",
    "href": "index.html#how-to-use-the-lecture-notes",
    "title": "EE BIOL C234",
    "section": "How to Use the Lecture Notes",
    "text": "How to Use the Lecture Notes\nYour left sidebar is your map to the course, showing all lectures—just a click away. On the right, you’ll see a table of contents specific to each lecture.\nIn this course, code examples will appear in blocks like this:\n\n1x &lt;- 1+1\n2x^2\n\n\n1\n\nCalculate 1+1 and assign it to the variable x.\n\n2\n\nCalculate the square of x.\n\n\n\n\nSee the little circle on the right? Hover over it for a quick explanation of the code. When you hover over the code block itself, you’ll also spot a “copy” button—perfect for copying and pasting it into your R console to try it out yourself (fun fact: that’s how a large portion of coding is done in real life).\nTo show stepped progress, we’ll often add to existing code blocks. New additions are highlighted for clarity. For example:\n\nx &lt;- 1+1 \nx^2 \n1x^3\n\n\n1\n\nCalculate the cube of x.\n\n\n\n\nYou’ll find key computational tools and R packages highlighted in purple (e.g., GitHub and ggplot2). R functions are indicated in red and always include parentheses, such as sum().\nThroughout the course, expect tips, tricks, and even a few fun facts sprinkled in. While not essential, these extras might give you an edge or deeper insight. Some of them are collapsible, so you can click to expand and explore them at your own pace. Look out for these in green boxes, like this:\n\n\n\n\n\n\nTips\n\n\n\n\n\n\n\n\nAs advertised, this is a tips box.",
    "crumbs": [
      "Weclome"
    ]
  },
  {
    "objectID": "01_intro.html",
    "href": "01_intro.html",
    "title": "\n1  Course goal\n",
    "section": "",
    "text": "1.1 Why Bother with This Course in the Age of AI?\nAlright, let’s cut to the chase. You signed up to study Ecology and Evolutionary Biology, not Computer Science. You probably envision yourself out in the field, knee-deep in mud, observing the subtle interactions of ecosystems—not stuck behind a screen, wrestling with semicolons and syntax errors. And now, with these fancy new AI tools that seem to do everything but your taxes, you might be wondering: why bother learning this computational stuff at all? Can’t a chatbot handle it all—generate analyses, whip up some plots, and call it a day?\nIt’s a fair question. Technology is reshaping everything, and science is no exception. But here’s the thing: just as biologists in the past had to master the microscope, today’s biologists need a strong foundation in computing. This course isn’t about turning you into a programmer; it’s about giving you the keys to harness technology effectively—so you’re steering the ship, not just along for the ride.\nBefore any anxiety sets in, let me assure you that this course is not gonna be a sink-or-swim experience. We’ll embark on a guided journey into computing, building your skills step by step. Think of it as learning a new language—with much simpler grammar, thankfully. We’ll use concrete example with annotated codes and hands-on exercises to support you along the way.\nAnd about those AI tools? Yes, they can be incredibly useful, no doubt. But relying on them blindly, without understanding the underlying principles, is like cooking from a recipe in a language you barely know. Sure, you might finish the dish, but there’s a good chance you’ll miss something critical—maybe misinterpret a step, add the wrong ingredient, or be puzzled by the end result. Computational literacy helps you to catch when the AI is leading you astray, saving you from headaches (and potentially flawed results) down the line.\nI get the temptation of the “easy button”, we all do. But investing in these skills now will pay off many times over. You’ll be a more efficient, more confident researcher—and, frankly, it will boost your chances of publishing in those coveted high-profile journals.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Course goal</span>"
    ]
  },
  {
    "objectID": "01_intro.html#what-youll-learn",
    "href": "01_intro.html#what-youll-learn",
    "title": "\n1  Course goal\n",
    "section": "\n1.2 What You’ll Learn",
    "text": "1.2 What You’ll Learn\nWe’ll cover the following topics, which are, in my view, the most essential computing skills for ecologists today. These are the things I wish I knew when I started grad school – it would have saved me so much time and frustration!\n\n1.2.1 Fluency with R\nWhat is our weapon of choice in this course? The R programming language. It is not the most well-polished language. It is not the fastest language. It is not the most user-friendly language. So, why R? Well, it is the lingua franca in our community. The computational tools in ecology are largely R-based. So, if you want to tap into this wealth, you’ll need a working knowledge of R.\n\n\n\n\n\n\nFeeling Adventurous?\n\n\n\n\n\nNot sold on R? You could try Julia, a newer language that’s faster, more elegant, and gaining popularity. The syntax is similar enough to R to make it a relatively easy transition, and it can even load R packages, so you can have the best of both worlds.\n\n\n\nR has also evolved dramatically in the past decade with the rise of the tidyverse suite. When I started grad school, I absolutely hated using R. But the tidyverse transformed that experience. It introduced a coherent way of handling and visualizing data—one that feels logical and intuitive. I firmly believe it’s the right approach to data manipulation and plotting.\n\n\n\n\n\n\nHeroes Behind the Tidyverse\n\n\n\n\n\nThe tidyverse revolution is largely thanks to Hadley Wickham, whose contributions earned him the COPSS Presidents’ Award, the top honor in statistics.\nBut it’s not a one-person show—the tidyverse thrives because of a vibrant community united by a shared vision (link).\n\n\n\n\n1.2.2 Crafting Publication-Ready Figures\nWith ggplot2, you’ll learn the Grammar of Graphics, one of the most powerful plotting systems out there. Beyond just producing high-quality figures, it will teach you a structured approach to data visualization.\nWhile ggplot2 is powerful, its defaults aren’t always perfect. We’ll cover design principles that enhance both the appeal and informativeness of your figures. This skill is quite useful—after all, figures often make the first impression on your readers. By the end of the course, you’ll be capable of creating figures like this: By the end of the course, you’ll be capable of creating figures like this:\n\n\nby Cédric Scherer\n\n\n1.2.3 The Art of Data Wrangling\nIn our daily research, data is rarely neat. Before you can start analyzing, you’ll likely spend hours organizing it into a usable format. Fortunately, dplyr and tidyr simplify this process, turning data wrangling into a clear, logical workflow.\nTo get a quick taste, let us imagine describing your morning routine. In base R, it might look like a convoluted nest of functions:\n\neat(dressed(shower(brush(wakeup(you)))))\n\nOr, a series of perplexing intermediate variables:\n\nyou_w &lt;- wakeup(you)\nyou_bw &lt;- brush(you_w)\nyou_sbw &lt;- shower(you_bw)\n...\n\nWith dplyr, however, it transforms into a straightforward, logical flow:\n\nyou |&gt; \n  wakeup() |&gt; \n  brush() |&gt; \n  shower() |&gt; \n  get_dressed() |&gt; \n  eat() \n\nIn the tidyverse ecosystem, each step of data manipulation is easy to write and, more importantly, easy to follow when reading other people’s code. We’ll introduce you to a core set of verbs—fewer than ten—that will handle over 90% of everyday tasks. You see, coding languages are indeed simpler than human languages!\n\n1.2.4 Scientific typsetting\nYes, Microsoft Word is great. But when it comes to updating figures, managing references, or maintaining consistent layouts, it can quickly turn into a labyrinthine headache. The core issue is that Word is a WYSIWYG editor—What You See Is What You Get (a weird acronym, I know).\nThe problem with WYSIWYG editors is that they often require manual tweaks—nudging an image here, adjusting a margin there—which not only consumes valuable time but also opens the door to errors. This is why separating content from layout is a strategy worth adopting. Instead of wrestling with formatting, you focus on the substance of your work—the data, the analysis, the insights—and let the tools handle the presentation.\nWhile there are several tools for this purpose (including the notorious LaTeX), we’ll focus on Quarto, a modern document preparation system tailored for researchers. Quarto allows you to seamlessly integrate code, references, and figures, producing professional outputs in submission-ready formats like Word or LaTeX with minimal effort. By the end of this course, you’ll be able to generate documents like this with a single click in R:\n\n\nby LaPreprint\n\n\n\n\n\n\n\nProfessional Typesetting\n\n\n\n\n\nWhile Quarto is powerful, sometimes you need specialized tools for optimal layout. LaTeX is one option, but it can feel outdated and cumbersome. We’ll briefly explore Typst, a modern alternative that offers the sophistication of LaTeX without the steep learning curve. It is also much faster and provided user-friendly interface for bebuggging. I firmlt believe Typst will replace LaTeX in the near future.\n\n\n\n\n1.2.5 Reproducible Research\nAs a data editor for a journal, I’m often struck by how many papers are challenging to reproduce—which I see as a huge problem for science. In this course, you’ll learn to make your research fully reproducible, which benefits not only the scientific community but also you—it makes it easier to revisit and build upon your work.\n\n\nPhD comics by Jorge Cham\n\nWe’ll get into version control using Git and GitHub, tools that help you track changes, back up your work, and collaborate effectively. Additionally, we’ll cover specific techniques in R that support reproducible workflows, ensuring your research stands on a solid foundation.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Course goal</span>"
    ]
  },
  {
    "objectID": "01_intro.html#course-plan-tentative",
    "href": "01_intro.html#course-plan-tentative",
    "title": "\n1  Course goal\n",
    "section": "\n1.3 Course Plan (Tentative)",
    "text": "1.3 Course Plan (Tentative)\n\n1.3.1 Introduction to R and RStudio\n\nInstalling R and RStudio\nNavigating the RStudio interface\nBasic R syntax and operations\nIntroduction to R packages and the tidyverse\n\nBasic Data Types: tibble and vector\n\n\n1.3.2 Introduction to ggplot2\n\n\nThe Grammar of Graphics concept\nCreating basic plots: scatter plots, line graphs, histograms, boxplots\nCustomizing plots with aesthetics, themes, and labels\nSaving and exporting plots\n\n1.3.3 Core dplyr Verbs for Data Manipulation\n\nUsing the pipe operator (|&gt;) for streamlined code\n\nfilter(): subsetting rows based on conditions\n\nselect(): choosing specific columns\n\nmutate(): creating and transforming variables\n\ngroup_by() and summarize(): aggregating and summarizing data\n\n1.3.4 Advanced ggplot2 Techniques\n\nDesign principles based on Fundamentals of Data Visualization by Claus O. Wilke\nAnnotation with ggrepel and gghighlight for labeling and highlighting key data\nEnhanced text formatting with ggtext\n\nMulti-panel plots with patchwork\n\nInteractive plots with ggiraph\n\nAnimated plots with gganimate to visualize changes over time\nHandling overplotting with ggpointdensity and ggdensity for dense scatter plots\nUncertainty visualization with ggdist and ggridgesmaterial\nApplying beautiful themes\nHow to adjust figures for presentations\n\n1.3.5 Importing and Cleaning Data\n\nImporting data with readr\n\nCleaning data with janitor\n\nHandling missing data\nHandling dates with lubridate\n\nJoining data with left_join()\n\n\n1.3.6 Making R Run Faster\n\n\nFaster data wrangling with dtplyr for speed improvements\nFunctional programming with purrr\n\nParallel computing with furrr to utilize multiple cores for concurrent execution\n\n1.3.7 Introduction to Quarto\n\nSetting up Quarto and integrating it with RStudio\nDocument structure and YAML metadata\nBlocks and chunk options: controlling code execution and output\nReference management with bibtex\n\nGenerating outputs: rendering documents to HTML, PDF, and Word formats\n\n1.3.8 Best Practices for Reproducible Research\n\nVersion control with Git and GitHub using RStudio\n\nUsing Quarto for reproducible reports: integrating code, analysis, and narrative text\ncreating reproducible environments and managing dependencies with renv\n\n\n1.3.9 How to Use AI in Coding\n\nIntroduction to GitHub Copilot",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Course goal</span>"
    ]
  },
  {
    "objectID": "01_intro.html#what-we-wont-cover",
    "href": "01_intro.html#what-we-wont-cover",
    "title": "\n1  Course goal\n",
    "section": "\n1.4 What We Won’t Cover",
    "text": "1.4 What We Won’t Cover\nThere’s a vast universe of computing out there, and we have to draw the line somewhere (before we all get lost in a black hole of code). There’s a reason why programmers in the Silicon Valley are paid so well—computing is hard! Here are some intriguing areas we won’t cover in this course, but I encourage you to explore them in the future:\n\nAdvanced Statistics and Machine Learning: These areas are extensive and deserve dedicated courses. To dive deeper into the world of algorithms and data models, I’d recommend starting with Tidymodels, which shares the same design philosophy as the tidyverse and should make for a smooth transition.\nWriting R Packages: Creating your own R packages is super useful, but might be overkill for our current adventure. If you’re interested in trying this, check out Hadley Wickham’s book R Packages as a starting point.\nHigh-Performance Computing and Big Data Analytics: Working with massive datasets and supercomputers is exciting (who doesn’t want to feel like they’re in a NASA control room?), but it often requires specialized knowledge and environment-specific setups. Plus, ecological datasets aren’t usually large enough to make your laptop break a sweat. We’ll stick to tools that run on a standard machine. If you’re eager to unleash the Kraken of computing power, UCLA’s Hoffman2 Cluster has you covered with detailed guidelines.\nBuilding Personal Websites: Maintaining a professional personal website is important for academics—it’s like your digital business card. Quarto makes it quite easy to set one up, but we won’t cover the details in this course. If you’re intrested, I’d recommend exploring the Quarto documentation on making websites.\nOther Programming Languages: Python, Julia, and friends are like the enticing dessert menu after a big meal—tempting but perhaps best saved for another time. As mentioned earlier, transitioning from R to Julia is relatively straightforward, so you can always explore other languages when you’re ready to expand your coding palate.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Course goal</span>"
    ]
  },
  {
    "objectID": "02_R_basics.html",
    "href": "02_R_basics.html",
    "title": "2  Basics of R and RStudio",
    "section": "",
    "text": "2.1 Installing R and RStudio\nLet’s begin at the most logical starting point: getting the software installed. To get started, I recommend this comprehensive installation guide that will walk you through the process seamlessly.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basics of R and RStudio</span>"
    ]
  },
  {
    "objectID": "02_R_basics.html#why-do-we-need-rstudio",
    "href": "02_R_basics.html#why-do-we-need-rstudio",
    "title": "2  Basics of R and RStudio",
    "section": "2.2 Why Do We Need RStudio?",
    "text": "2.2 Why Do We Need RStudio?\nThink of R as a high-performance engine—capable of incredible feats but not particularly user-friendly on its own. RStudio is the sleek vehicle that lets you harness that power efficiently. While you could interact with R through a basic terminal, RStudio’s interface smoothly handles the otherwise clunky commands and makes certain tasks—like visualizing results or managing code—remarkably more accessible.\n\n\n\n\n\n\nAlternative Options Worth Considering\n\n\n\n\n\nDespite RStudio’s popularity, it is hardly the only game in town. VSCode has emerged as a popular alternative—a versatile, general-purpose IDE that supports multiple programming languages. It’s well-designed, feature-rich, and, importantly, free and open-source. Personally, I use VSCode for most of my R programming work.\nAnother option on the horizon is Positron, developed by the same innovative team behind RStudio. It’s the modern evolution of RStudio, currently in beta but already showing great promise. It will eventually replace RStudio as the go-to IDE for R programming.\n\n\n\nRStudio is an incredible well-designed software that makes your life easier when working with R (and Python). It has a lot of features that make your life easier. We’ll explore many of these features as we progress, starting with making your R code look better.\n\n\n\n\n\n\nMaking Your Code look prettier\n\n\n\nOne of the subtle joys of programming is crafting code that’s not only functional but also aesthetically pleasing. To enhance the readability of your R scripts, consider installing the Fira Code font. Instruction can be found here and here.\nAnother way to make your code more readable is to format the codes according to the tidyverse style guide. Of course, no one wants to memorize all. Luckily, you can use the styler package to do this as an addin in RStudio (link).",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basics of R and RStudio</span>"
    ]
  },
  {
    "objectID": "02_R_basics.html#getting-r-to-work-for-you",
    "href": "02_R_basics.html#getting-r-to-work-for-you",
    "title": "2  Basics of R and RStudio",
    "section": "2.3 Getting R to Work for You",
    "text": "2.3 Getting R to Work for You\nIn the grand tradition of programming tutorials, let’s start with the classic “Hello, World!”—a humble beginning to our journey with R.\n\n1print(\"Hello, World!\")\n\n\n1\n\nThe print() function displays the text within on the console.\n\n\n\n\n[1] \"Hello, World!\"\n\n\nNext, you can use R as a straightforward calculator:\n\n3 + 2\n\n[1] 5\n\n\nYou can also store results in variables (so you can use them later):\n\n1x &lt;- 3 + 2\n2x\n\n\n1\n\nAssigns the value of 3 + 2 to the variable x.\n\n2\n\nThe x displays the value of x on the console.\n\n\n\n\n[1] 5\n\n\n\n\n\n\n\n\nWhy does R use &lt;-?\n\n\n\n\n\nIn R, &lt;- is for assignment while = is for function arguments. You can technically use = for assignment in almost all cases, meaning x &lt;- 3 + 2 is equivalent to x = 3 + 2. But then why does R continue to favor &lt;-?\nOne reason is conceptual clarity. In R, the distinction between assignment and function arguments is explicit, providing a cleaner syntax and helping avoid ambiguity in complex code. By differentiating assignment with &lt;-, R signals that an action is being performed, where data is transferred from one entity to another. This reinforces the principle that assignment and function arguments are inherently distinct constructs.\nA second reason is flexibility. R allows for the reverse assignment arrow, -&gt;, which lets you assign values in the opposite direction. For instance, 3 -&gt; x assigns the value 3 to x, a feature that can sometimes be handy.\nBut why don’t most other languages use a similar convention? One factor is typing efficiency: &lt;- requires three keystrokes, while = only requires one (although you eventually get used to it). However, there’s also a historical element here: early keyboards designed for statistical computing actually had a dedicated &lt;- key, which made the operator as convenient as = (source):\n\n\n\nFrom https://dcl-prog.stanford.edu/data-structure-basics.html\n\n\n\n\n\n\nExercise\n\nCreate a variable y and assign it the value of 5 * 3. Then display the value of y on the console.\n\n\nExerciseSolution\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nCreate a variable z that is half of the value of y, and then display the value of z on the console.\n\n\nExerciseSolution\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basics of R and RStudio</span>"
    ]
  },
  {
    "objectID": "02_R_basics.html#using-ai-in-rstudio",
    "href": "02_R_basics.html#using-ai-in-rstudio",
    "title": "2  Basics of R and RStudio",
    "section": "2.4 Using AI in RStudio",
    "text": "2.4 Using AI in RStudio\nThere are many basic functions in R that you can use. For example, the sqrt() function calculates the square root of a number. I know that it could be annoying to remember all the functions, but luckily we have the powerful AIs to help us. It is pretty easy to use Copilot, a powerful AI tool developed by Github, to get the function you need. It is straightforward to use it in RStudio (link).\nHowever, AIs can be unreliable sometimes. To make sure it works, you can always use the ? to double check. For example, to see the documentation R has on the sqrt() function, you can use the following code:\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nIn addition, you should check some simple cases to make sure the function works as expected. For example, you can use the following code to check the sqrt() function:\n\nsqrt(1) == 1\n\n[1] TRUE\n\nsqrt(4) == 2\n\n[1] TRUE",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basics of R and RStudio</span>"
    ]
  },
  {
    "objectID": "02_R_basics.html#installing-packages",
    "href": "02_R_basics.html#installing-packages",
    "title": "2  Basics of R and RStudio",
    "section": "2.5 Installing Packages",
    "text": "2.5 Installing Packages\n\n2.5.1 Standard approach\nTo unlock R’s full potential, you’ll often need to install additional packages—think of them as apps that extend your smartphone’s capabilities. This is a one-time process for each package on your computer. For example, to install the ggplot2 package:\n\ninstall.packages(\"ggplot2\")\n\nAfter that, simply load it when you need it:\n\nlibrary(ggplot2)\n\n\n\n\n\n\n\nA Quirk to Watch Out For\n\n\n\n\n\nThis is the first design inconsistencies when using R: when installing a package, you enclose its name in quotes, but when loading it, you don’t. It’s a small quirk, but one that can trip you up if you’re not careful (speaking from experience :-(\nThere will be many others along the way. I will try to point them out as we go along.\n\n\n\n\n\n\n\n\n\nNot All Packages Are on CRAN\n\n\n\nNotably, not all packages are on CRAN. For example, many of them are on GitHub, GitLab, or other platforms. To install these packages, you can use the devtools package. For example, to install the ggthemr package from GitHub:\n\n1# install.packages(\"devtools\")\n2library(devtools)\n3devtools::install_github(\"cttobin/ggthemr\")\n\n\n1\n\nInstall the devtools package.\n\n2\n\nLoad the devtools package.\n\n3\n\nInstall the ggthemr package from GitHub.\n\n\n\n\n\n\n\n\n2.5.2 An alternative approach\nI prefer to use a different strategy. Consider using the pacman package. It automatically detects if the pointed package is installed and installs it if it’s not, and then load it. Here’s how you can use it:\n\n1# install.packages(\"pacman\")\n2library(pacman)\n3p_load(ggplot2)\n\n\n1\n\nKeep in mind that you’ll need to install pacman first, as it’s not part of R’s base packages.\n\n2\n\nLoad the pacman package.\n\n3\n\nUse p_load() to install and load the ggplot2 package in one go.\n\n\n\n\nThis can greatly simplify things when sharing code. You don’t have to wonder whether a particular library is installed on someone else’s system—p_load() handles it gracefully.\nBetter yet, for best practice, I strongly recommend the following command:\n\n1pacman::p_load(ggplot2)\n\n\n1\n\np_load() function is called from the pacman package\n\n\n\n\nWhat is this mysterious :: here? It simply means that we are loading the p_load() function from the pacman package. It allows you to access a function from a package without loading the entire package. This can help avoid conflicts with other packages that might have a similarly named function (which is a huge source for hidden errors!).\n\n\nExercise: Installing Packages\nInstall the package gt using either the standard method or the pacman method.\n\nExerciseSolution\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basics of R and RStudio</span>"
    ]
  },
  {
    "objectID": "02_R_basics.html#meet-the-tidyverse",
    "href": "02_R_basics.html#meet-the-tidyverse",
    "title": "2  Basics of R and RStudio",
    "section": "2.6 Meet the Tidyverse",
    "text": "2.6 Meet the Tidyverse\nAs stated in its official website:\n\nThe tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures.\n\nInstalling it may take a bit:\n\ninstall.packages(\"tidyverse\")\n\nOnce done, loading it is straightforward and a common part of most R scripts (I usually begin nearly all my scripts with this line):\n\nlibrary(tidyverse)\n\nWarning: package 'tidyr' was built under R version 4.2.3\n\n\nWarning: package 'readr' was built under R version 4.2.3\n\n\nWarning: package 'dplyr' was built under R version 4.2.3\n\n\nWarning: package 'stringr' was built under R version 4.2.3\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ lubridate 1.9.3     ✔ tibble    3.2.1\n✔ purrr     1.0.2     ✔ tidyr     1.3.1\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nAs you can see, Looking at the message generated by executing the above line, we see that nine packages are now loaded. They are called ggplot2, tibble, and so on. We will get to know these in more detail throughout the class.\n\n\n\n\n\n\nWhat does conflicts message mean?\n\n\n\n\n\nAs you can see from the message, it shows what conflicts are there. The two conflicts are horrible design choices in tidyverse. Many mysterious bugs happen because of these conflicts. To avoid these, you can use the following code:\n\n1library(conflicted)\n2library(tidyverse)\n3conflict_prefer(\"filter\", \"dplyr\")\n4conflict_prefer(\"lag\", \"dplyr\")\n\n\n1\n\nLoad the conflicted package.\n\n2\n\nLoad the tidyverse package.\n\n3\n\nThis code says that if there is a conflict on filter, always prefer dplyr.\n\n4\n\nThis code says that if there is a conflict on lag, always prefer dplyr.\n\n\n\n\nAnother way is to just write your code using the package::funcion() format:\n\ndplyr::filter()\ndplyr::lag()\n\nGiven how often you’ll use these functions, I find it annoying with this approach. But it’s a personal choice.\n\n\n\n\n\n\n\n\n\nWant to avoid the annoying messages?\n\n\n\n\n\nIf you do not want to see the messages (although I do not recommend), you can use the suppressPackageStartupMessages() function. For example, you can use the following code to load the tidyverse package:\n\nsuppressPackageStartupMessages(library(tidyverse))\n\nThis approach hides the typical start-up output, though it remains entirely optional.\n\n\n\nWe’ll rely on the tidyverse extensively throughout this course.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Basics of R and RStudio</span>"
    ]
  },
  {
    "objectID": "03_data_structure.html",
    "href": "03_data_structure.html",
    "title": "3  Basic Data Structure",
    "section": "",
    "text": "3.1 Vector\nA data structure is an orderly, efficient way to store and retrieve data. While it may feel a bit abstract if you’re new to coding, think of these structures as the “nouns” in your programming language (with data wrangling serving as the “verbs”).\nR has provided many data structures. Fortunately, nine times out of ten, you’ll only need to worry about two: vector and tibble.\nA vector is a one-dimensional array—like a row of seats in a movie theater that only allows one type of audience member, be they numeric, character, or logical. We create them with the c() function. For example:\n1numbers &lt;- c(1, 2, 3, 4, 5)\n2numbers\n\n\n1\n\nCreate a vector of numbers from 1 to 5.\n\n2\n\nDisplay the numbers vector.\n\n\n\n\n[1] 1 2 3 4 5\nVectors form the backbone of R scripts. They’re how you can store the number of penguins wandering around Antarctica, keep track of class attendance, or tally cars on the highway. A key detail: everything in a vector must share the same type. Some common types are:\nBelow, we make a few different vectors to illustrate these types:\n1numbers &lt;- c(1.1, 2.2, 3.3, 4.4, 5.5)\n2characters &lt;- c(\"a\", \"b\", \"c\")\n3logicals &lt;- c(TRUE, FALSE, TRUE)\n4factors &lt;- factor(c(\"a\", \"b\", \"c\"))\n\n\n1\n\nCreate a vector of numbers from 1 to 5.\n\n2\n\nCreate a vector of characters.\n\n3\n\nCreate a vector of logicals.\n\n4\n\nCreate a vector of factors.\nWe can also extract data from a vector using the square brackets []. For example:\n1numbers[1]\n2characters[2]\n\n\n1\n\nExtract the first element from the numbers vector.\n\n2\n\nExtract the second element from the characters vector.\n\n\n\n\n[1] 1.1\n[1] \"b\"\nNote that the index starts from 1, not 0. This is a common source of confusion for those coming from languages like Python or C. I personally prefer the 1-based index, as this is more intuitive.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Data Structure</span>"
    ]
  },
  {
    "objectID": "03_data_structure.html#vector",
    "href": "03_data_structure.html#vector",
    "title": "3  Basic Data Structure",
    "section": "",
    "text": "What does c() stand for\n\n\n\n\n\nc() means “combine.” Yes, it’s a slightly cryptic name for what you’ll soon be typing all the time, but you’ll get used to it.\n\n\n\n\n\nnumeric (like 3.14 or 42)\ncharacter (like “Hello” or “World”)\nlogical (TRUE or FALSE)\nfactor (categorical data)\n\n\n\n\n\n\n\n\n\nBe aware of data types\n\n\n\nR automatically assigns the data type for each vector, which can save time but also lead to (unwanted) surprises. For instance, sometimes 1 appears as a character rather than a number—something that can introduce annoying bugs. Avoid headaches by checking data types with class(). For example:\n\nclass(numbers) \n\n[1] \"numeric\"\n\n\nA horror story (not in R but in Excel) is that the auto-convert feature messes up gene names like SEPT4 to 4-Sept (datatype from character to datetime). This has affected a ton of genetic papers. So, always be aware of the data types!\n\n\n\n\n\n\nExercise\n\nCreate a vector of numbers from -1 to -3, and then extract the second element.\n\n\nExerciseSolution\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nCreate a vector of characters with your name and surname.\n\n\nExercise\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nCreate a vector of logicals by flipping a coin three times.\n\n\nExercise\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Data Structure</span>"
    ]
  },
  {
    "objectID": "03_data_structure.html#tibble",
    "href": "03_data_structure.html#tibble",
    "title": "3  Basic Data Structure",
    "section": "3.2 Tibble",
    "text": "3.2 Tibble\nA tibble (brought to you by the tidyverse) is essentially a set of vectors bound together in columns—like a multi-row, multi-column theater, where each column houses a single data type.\n\nAs a simple xample,\n\n1library(tidyverse)\n2tibble(\n3    x = c(1, 2, 3),\n4    y = c(\"a\", \"b\", \"c\"),\n5    z = c(TRUE, FALSE, TRUE)\n6)\n\n\n1\n\nLoad the tidyverse package, as tibble is from it.\n\n2\n\nCreate a tibble.\n\n3\n\nCreate the first column as a vector of numbers from 1 to 3.\n\n4\n\nCreate the second column as a vector of characters.\n\n5\n\nCreate the third column as a vector of logicals.\n\n6\n\nAlways remember to close the function with a parenthesis.\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\nAnother way to write tibble\n\n\n\n\n\nThere is another equivalent way of writing it rowwisely. For example,:\n\n1tribble(\n2  ~x, ~y,\n3  1, \"a\",\n  2, \"b\", \n  3, \"c\"\n)\n\n\n1\n\nCreate a tibble rowwisely (note the function name is different from tibble).\n\n2\n\nDefine the column names.\n\n3\n\nDefine the first row.\n\n\n\n\n\n  \n\n\n\nThis is perfect when typing in smaller datasets by hand.\n\n\n\nTibbles come with plenty of benefits over base R’s classic data frame—particularly in how they track and preserve data types. You’ll notice each column explicitly labeled as dbl (double) or chr (character), which can save you from those frustrating mysteries where your numeric data gets disguised as text.\nTibbles also enforce a neat and consistent data layout, called Tidy Data, which is a godsend when you’re dealing with other people’s messy spreadsheets. Quoting from Hadley Wickham (link):\n\nTidy datasets are easy to manipulate, model and visualize, and have a specific structure: each variable is a column, each observation is a row, and each type of observational unit is a table.\n\n\n\n\nFrom https://r4ds.hadley.nz/data-tidy.html\n\n\nWe will learn more about working with tibble more in the next sections, but for now, let’s move on to our example dataset.\n\nExercise\nCreate a tibble with the following columns:\n\nname with your name and surname\nage with your age\nis_student with a logical value\n\n\nExerciseSolution\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Data Structure</span>"
    ]
  },
  {
    "objectID": "03_data_structure.html#our-example-dataset-penguins",
    "href": "03_data_structure.html#our-example-dataset-penguins",
    "title": "3  Basic Data Structure",
    "section": "3.3 Our example dataset: penguins",
    "text": "3.3 Our example dataset: penguins\nWe’ll soon learn how to import data (another comedic ordeal in itself), but for now, let’s borrow the penguins dataset from the palmerpenguins package. It covers three penguin species—Adelie, Chinstrap, and Gentoo—and gives us some useful variables to play with. Who doesn’t love penguins?\n\n\n\nArtwork by allison_horst\n\n\nFirst things first, let us load the penguins dataset.\n\n1# install.packages(\"palmerpenguins\")\n2library(palmerpenguins)\n3data(package = \"palmerpenguins\")\n\n\n1\n\nIf you have not installed the palmerpenguins package, you can install it by uncommenting this line.\n\n2\n\nLoad the palmerpenguins package.\n\n3\n\nLoad the penguins dataset.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Data Structure</span>"
    ]
  },
  {
    "objectID": "03_data_structure.html#take-a-look-at-your-data",
    "href": "03_data_structure.html#take-a-look-at-your-data",
    "title": "3  Basic Data Structure",
    "section": "3.4 Take a Look at your Data",
    "text": "3.4 Take a Look at your Data\nAs a first rule, always, always take a look at your data. The simplest way is simply to print it out:\n\n1penguins\n\n\n1\n\nDisplay the penguins dataset.\n\n\n\n\n\n  \n\n\n\nThis prints about the first couple rows of the dataset (another reason to love tibble over data frame in base R).\nYou may notice some NA values in the dataset. These are missing values, which are common in real-world datasets. We’ll learn how to handle them later.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Data Structure</span>"
    ]
  },
  {
    "objectID": "03_data_structure.html#a-more-structured-view",
    "href": "03_data_structure.html#a-more-structured-view",
    "title": "3  Basic Data Structure",
    "section": "3.5 A more structured view",
    "text": "3.5 A more structured view\nIf you’d like a better view of your dataset, try the skim() function from the skimr package:\n\n1pacman::p_load(skimr)\n2skim(penguins)\n\n\n1\n\nLoad the skimr package.\n\n2\n\nDisplay the summary of the penguins dataset.\n\n\n\n\n\nData summary\n\n\nName\npenguins\n\n\nNumber of rows\n344\n\n\nNumber of columns\n8\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nfactor\n3\n\n\nnumeric\n5\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: factor\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nordered\nn_unique\ntop_counts\n\n\n\n\nspecies\n0\n1.00\nFALSE\n3\nAde: 152, Gen: 124, Chi: 68\n\n\nisland\n0\n1.00\nFALSE\n3\nBis: 168, Dre: 124, Tor: 52\n\n\nsex\n11\n0.97\nFALSE\n2\nmal: 168, fem: 165\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nbill_length_mm\n2\n0.99\n43.92\n5.46\n32.1\n39.23\n44.45\n48.5\n59.6\n▃▇▇▆▁\n\n\nbill_depth_mm\n2\n0.99\n17.15\n1.97\n13.1\n15.60\n17.30\n18.7\n21.5\n▅▅▇▇▂\n\n\nflipper_length_mm\n2\n0.99\n200.92\n14.06\n172.0\n190.00\n197.00\n213.0\n231.0\n▂▇▃▅▂\n\n\nbody_mass_g\n2\n0.99\n4201.75\n801.95\n2700.0\n3550.00\n4050.00\n4750.0\n6300.0\n▃▇▆▃▂\n\n\nyear\n0\n1.00\n2008.03\n0.82\n2007.0\n2007.00\n2008.00\n2009.0\n2009.0\n▇▁▇▁▇\n\n\n\n\n\nThink of skim() as your quick backstage pass, telling you how many rows, columns, missing values, and data types you’re dealing with. Trust me, a few seconds spent peeking at your data can save hours of confusion down the line.\n\nExercise\niris is a widely-used dataset of plant traits. It is a default dataset in R. Take a look at the iris dataset using the skim() function.\n\nExerciseSolution\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "A First Look at R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Basic Data Structure</span>"
    ]
  },
  {
    "objectID": "04_ggplot_basic.html",
    "href": "04_ggplot_basic.html",
    "title": "4  Welcome to the World of ggplot2",
    "section": "",
    "text": "4.1 Why so much focus on Graphs?\nAs you can see from the syllabus, we will spend a lot of time on making graphs. Why? Because humans are visual beings. There’s a reason why The New York Times invests in top-tier graphic designers to craft their visuals. A well-designed graph can illuminate complex data in a way that words alone often can’t.\nNow, don’t get me wrong. Graphs aren’t a replacement for text. We still need words to convey intricate ideas and the necessary nuances that come with any scientific discourse. But the sad truth is that most people won’t read your entire paper, they will likely skim it. So if you want your work to resonate, you need to make your key findings as clear as possible. In a world overflowing with information, effective visuals are becoming more and more important.\nThe realm of data visualization has exploded with new tools and frameworks. Among them, ggplot2 stands out. Why focus on ggplot2? Because it encapsulates the right approach to thinking about graphics. Much like learning the grammar of a new language, understanding the “grammar of graphics” will make your visualizations more structured and easier. In addition, it has got a large community (extension libraries).",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Welcome to the World of `ggplot2`</span>"
    ]
  },
  {
    "objectID": "04_ggplot_basic.html#crafting-our-first-graph-with-ggplot2",
    "href": "04_ggplot_basic.html#crafting-our-first-graph-with-ggplot2",
    "title": "4  Welcome to the World of ggplot2",
    "section": "4.2 Crafting Our First Graph with ggplot2",
    "text": "4.2 Crafting Our First Graph with ggplot2\nThen we quickly visualize the data using the ggplot2 package. Let us load the penguins dataset from the palmerpenguins package, as we learnt in the previous chapter.\n\npacman::p_load(palmerpenguins) \n\nSuppose we’re curious about the relationship between bill length and bill depth in penguins. In the palmerpenguins dataset, these are represented by bill_length_mm and bill_depth_mm, respectively. Let’s visualize this relationship using ggplot2:\n\n1library(ggplot2)\n2ggplot(\n3  data = penguins,\n4  aes(x = bill_length_mm,\n5      y = bill_depth_mm)\n6) +\n7  geom_point()\n\n\n1\n\nLoad the ggplot2 package.\n\n2\n\nStart a new plot with the function ggplot().\n\n3\n\nSpecify the dataset used in the plot.\n\n4\n\nDefine the x-axis variable as bill_length_mm.\n\n5\n\nDefine the y-axis variable as bill_depth_mm.\n\n6\n\nAdd a layer to the plot.\n\n7\n\nA layer of points to the plot.\n\n\n\n\n\n\n\n\n\n\n\nWhen you run this code, you should see a scatter plot of flipper length against body mass. Congratulations! You’ve just made your first ggplot2 graph.\nLet’s dissect this enchanting code piece by piece:\n\nThe + operator is your magical wand, allowing you to add layers to your plot. Each layer is a graphical element that enhances your masterpiece.\naes() is used to define the aesthetics of the plot. Here, we map the flipper length to the x-axis and body mass to the y-axis.\ngeom_point() is part of a vast family of geom_* functions that define what you add on top of your graph—points, lines, bars, you name it.\n\nOnce you grasp these concepts, ggplot2 becomes as intuitive as pie (and just as satisfying). When creating scatter plots, you need data, define your axes, and decide what magical elements to add (like points). To abstract it a bit, here’s the fundamental grammar of ggplot2:\n\nggplot(\n1  data = &lt;DATA&gt;,\n2  aes(x = &lt;X&gt;, y = &lt;Y&gt;)\n3) +\n4  &lt;GEOM_FUNCTION&gt;(aes(...))\n\n\n1\n\nSpecify the dataset.\n\n2\n\nDefine the x- and y-axis variable.\n\n3\n\nAdd a layer to the plot.\n\n4\n\nSpecify the type of layer to add.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Welcome to the World of `ggplot2`</span>"
    ]
  },
  {
    "objectID": "04_ggplot_basic.html#tuning-our-plot",
    "href": "04_ggplot_basic.html#tuning-our-plot",
    "title": "4  Welcome to the World of ggplot2",
    "section": "4.3 Tuning our Plot",
    "text": "4.3 Tuning our Plot\nOur plot is functional but not entirely useful. What about different species? To do this, we can use different colors to distinguish them:\n\nggplot(\n  data = penguins,\n  aes(\n    x = bill_length_mm,\n    y = bill_depth_mm\n  )) +\n1  geom_point(aes(color = species))\n\n\n1\n\nWe map the species variable to the color aesthetic.\n\n\n\n\n\n\n\n\n\n\n\nBut why stop at color? Let’s add another layer of distinction by incorporating shapes:\n\nggplot(\n  data = penguins,\n  aes(\n    x = bill_length_mm,\n    y = bill_depth_mm \n  )) +\n1  geom_point(aes(color = species, shape = species))\n\n\n1\n\nDifferentiate the species by both the color and the shape of the points.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Welcome to the World of `ggplot2`</span>"
    ]
  },
  {
    "objectID": "04_ggplot_basic.html#do-not-use-the-default-theme",
    "href": "04_ggplot_basic.html#do-not-use-the-default-theme",
    "title": "4  Welcome to the World of ggplot2",
    "section": "4.4 Do not use the default theme",
    "text": "4.4 Do not use the default theme\nThe default theme is not good. Besides being aesthetically bland, the grey background guzzles a ton of ink when you print. We can change it by adding a theme to the plot. Themes control the non-data elements of your plot—think of them as the outfit your graph wears to impress. Here’s how you can do it:\n\nggplot(\n  data = penguins,\n  aes(\n    x = bill_length_mm,\n    y = bill_depth_mm \n  )) +\n  geom_point(aes(color = species, shape = species)) +\n1  theme_bw()\n\n\n1\n\nApply the theme_bw() theme to the plot.\n\n\n\n\n\n\n\n\n\n\n\nThe theme_bw() is a great starting point—it removes the background gridlines and opts for a clean white backdrop, making your plot easier on the eyes and more printer-friendly. ggplot2 comes with a plethora of themes (check them out here). We’ll dive deeper into theme_*() functions in future classes, but for now, remember that you can transform your plot’s appearance by simply adding a theme_*() function.\nPersonally, I rarely stick to themes provided in the ggplot2 library. I prefer the flair of themes from other packages. My personal favorite? theme_nice() from the jtools package:\n\n1# install.packages(\"jtools\")\nggplot(\n  data = penguins,\n  aes(\n    x = bill_length_mm,\n    y = bill_depth_mm,\n    color = species,\n    shape = species\n  )) +\n  geom_point() +\n2  jtools::theme_nice()\n\n\n1\n\nInstall the jtools package if you haven’t already.\n\n2\n\nApply the theme_nice() from the package jtools theme to the plot.\n\n\n\n\n\n\n\n\n\n\n\n\nOf course, this isn’t yet a publication-ready figure, but it’s a fantastic start. We’ll explore more customization options in future classes.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Welcome to the World of `ggplot2`</span>"
    ]
  },
  {
    "objectID": "04_ggplot_basic.html#exercise",
    "href": "04_ggplot_basic.html#exercise",
    "title": "4  Welcome to the World of ggplot2",
    "section": "Exercise",
    "text": "Exercise\n\nTry to plot the relationship between Body mass (body_mass_g) and Bill depth (bill_depth_mm) for the penguins dataset. Use the species variable to color the points.\n\n\nExerciseSolution\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nExplore themes. Try to change the theme of the plot to theme_minimal() or theme_classic(). What do you observe?\n\n\nExerciseSolution\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Welcome to the World of `ggplot2`</span>"
    ]
  },
  {
    "objectID": "05_aesmatic_mapping.html",
    "href": "05_aesmatic_mapping.html",
    "title": "5  A Detailed Look at Grammar of Graphics",
    "section": "",
    "text": "5.1 Aesthetic Mappings",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Detailed Look at Grammar of Graphics</span>"
    ]
  },
  {
    "objectID": "05_aesmatic_mapping.html#aesthetic-mappings",
    "href": "05_aesmatic_mapping.html#aesthetic-mappings",
    "title": "5  A Detailed Look at Grammar of Graphics",
    "section": "",
    "text": "5.1.1 What is an Aesthetic?\nIn ggplot2, aesthetics are the magical connections between your data and how it looks on the plot. The aes() function is like the matchmaker that sets up these relationships. It maps variables in your data to visual properties in your plot. Thus, everything inside the aes() function should correspond to a column in your dataset.\nTo see this, let us again consider plotting the body_mass_g against the bill_depth_mm of the penguins dataset. Suppose we want to color all points blue:\n\nUsing Aesthetic Mapping for a Fixed ColorSetting Color Outside aes()\n\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm \n    )\n) +\n1    geom_point(aes(color = \"blue\")) +\n    theme_minimal()\n\n\n1\n\nThe color aesthetic is set to “blue”.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm \n    ) \n) +\n1    geom_point(color = \"blue\") +\n    theme_minimal()\n\n\n1\n\nThe color is not within aes() function.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAs we can see, the second option is correct. Because \"blue\" is not a variable in the penguins dataset, it is not a valid aesthetic mapping. Thus, the correct way to do it is to take the color as a non-aesthetic mapping.\n\n\n5.1.2 What can you map to?\nYou can map many aesthetics in ggplot2. We have already seen that:\n\nx and y for the x- and y-axis\ncolor for the color of the points. This is a big and very important topic. We will discuss it in more detail in the next section.\nshape for the shape of the points. There are 25 different shapes you can choose from (link). I admit that I google them every time I need to use them.\n\nThere are some other common aesthetics you can map to points in ggplot2:\n\nsize for the size of the points\nalpha for the transparency of the points. It ranges from 0 (completely transparent) to 1 (completely opaque)\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(data = penguins, \n    aes(x = bill_length_mm, y = bill_depth_mm)\n) +\n    geom_point(\n        aes(\n1            color = species,\n2            size = body_mass_g\n        ),\n3        alpha = 0.5,\n4        shape = 21,\n5        fill = \"white\"\n    ) +\n    theme_minimal()\n\n\n1\n\nThe species variable is mapped to the color aesthetic. Different species will have different colors.\n\n2\n\nThe body_mass_g variable is mapped to the size aesthetic. Different body masses will have different sizes.\n\n3\n\nThe alpha is the same for all. 0.5 makes the points semi-transparent.\n\n4\n\nThe shape is the same for all. This makes the points filled circles.\n\n5\n\nThe fill is the same for all. This makes the points white.\n\n\n\n\n\n\n\n\n\n\n\nIf you understand the above code, you would have a solid working knowledge of aesthetic mapping in ggplot2:\n\nWe see that two variables are mapped to the color and size aesthetics. This means that different species will have different colors and different body masses will have different sizes. Thus, you can map different variables to different aesthetics. This gives us great flexibility in how we can visualize our data.\nA mapped aesthetic will have a legend by default. This is always needed to interpret the plot. Two different aesthetics will have two different legends.\nBecause alpha, shape, and fill are set outside the aes() function, all points will have the same transparency, shape, and fill.\n\n\n\nExercise\n\nFix the Aesthetic Mapping. Run the following code. Identify the error and correct it.\n\n\nExerciseSolution\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nalpha is incorrectly placed inside aes() because it is fixed, and size should be inside aes() as body_mass_g is a variable in the data.\n\n\n\n\nCustomize Aesthetics. Adjust the transparency (alpha) based on body_mass_g, change the shape based on island, and set all points to purple.\n\n\nExerciseSolution\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Detailed Look at Grammar of Graphics</span>"
    ]
  },
  {
    "objectID": "05_aesmatic_mapping.html#geometric-objects",
    "href": "05_aesmatic_mapping.html#geometric-objects",
    "title": "5  A Detailed Look at Grammar of Graphics",
    "section": "5.2 Geometric objects",
    "text": "5.2 Geometric objects\nGeometric objects (geoms) are the visual representations of your data. Think of them as the artists painting your data onto the canvas. For example, we have already used geom_point() to create a scatter plot. ggplot2 offers a variety of geoms (geom_*()) to create different types of plots. As an example, we can use a different geometric object for the same data above:\n\ngeom_point()geom_smooth()\n\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm \n    ) \n) +\n1    geom_point() +\n    theme_minimal()\n\n\n1\n\nThe geom_point() function is used to create a scatter plot.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm \n    ) \n) +\n1    geom_smooth() +\n    theme_minimal()\n\n\n1\n\nThe geom_smooth() function is used to create a smooth line that fits the trend of the data.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor the two plots above, left and right have the same data, same axis, but different geometric objects. The left plot uses geom_point() to create a scatter plot, while the right plot uses geom_smooth() to create a smooth line that fits the trend of the data.\nYou can use more than one geometric object in a plot. For example, you can add a smooth line to the scatter plot:\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm \n    ) \n) +\n1    geom_point() +\n2    geom_smooth() +\n    theme_minimal()\n\n\n1\n\nThe geom_point() function is used to create a scatter plot.\n\n2\n\nThe geom_smooth() function is used to create a smooth line that fits the trend of the data.\n\n\n\n\n\n\n\n\n\n\n\n\nExercise\nWe want to explore the relationship between body_mass_g and flipper_length_mm. Please plot the data with both the points and a smooth trend line. What preliminary conclusions can you draw from the plot?\n\nExerciseSolution\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Detailed Look at Grammar of Graphics</span>"
    ]
  },
  {
    "objectID": "05_aesmatic_mapping.html#organizational-structure",
    "href": "05_aesmatic_mapping.html#organizational-structure",
    "title": "5  A Detailed Look at Grammar of Graphics",
    "section": "5.3 Organizational structure",
    "text": "5.3 Organizational structure\nThis is not something typiucally taught in length in the typical ggplot2 tutorial. I kindly learnt it from experience, through many scratching many heads with mysterious codes.\n\n5.3.1 Global vs Local Aesthetic Mapping\nTo show this, we introduce another aesthetic mapping: group. It is a central aes that is used to group data. For example, in the figure above, it is quite annoying that the smooth line desciebes the average trend across species, but we are often only intrested within species. We can group the data by species so that the smooth line is fitted to each species separately.\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    ) \n) +\n    geom_point() + \n1    geom_smooth(aes(group = species)) +\n    theme_minimal()\n\n\n1\n\nThe species variable is mapped to the group aesthetic. This means that the smooth line will be fitted to each species separately.\n\n\n\n\n\n\n\n\n\n\n\nBut the figure itself is still not very informative as it is diffcult to tell which species is which. We can add a color aesthetic\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    ) \n) +\n    geom_point(aes(color = species)) + \n    geom_smooth(aes(group = species)) + \n    theme_minimal()\n\n\n\n\n\n\n\n\nHowever, it is annoying that the color only applies to the points, but not the smooth line. There are two ways to fix this.\n\nMapping species to color separatelyMapping species to color together\n\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    ) \n) +\n1    geom_point(aes(color = species)) +\n2    geom_smooth(aes(group = species, color = species)) +\n    theme_minimal()\n\n\n1\n\nThe species variable is mapped to the color aesthetic for the points.\n\n2\n\nThe species variable is mapped to the color aesthetic for the smooth line.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm,\n1        group = species,\n        color = species\n    ) \n) +\n    geom_point() + \n    geom_smooth() +  \n    theme_minimal()\n\n\n1\n\nThe species variable is mapped to the color aesthetic in the beginning but not in the geom_point() or geom_smooth() functions.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThese two approaches produce the same results! In brief, what is included within the ggplot() function is applied to all geometric objects, while what is included within the geom_*() functions is only applied to that specific geometric object. A best practice is, whenver you are unsure, to include the aesthetic mapping in the geom_*() function.\n\n\n\n\n\n\nA cumbersome way (NOT RECOMMENDED)\n\n\n\n\n\nTo help you better understand, we can write quite cumbersome codes to achieve the same results :\n\nlibrary(ggplot2)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins\n) +\n    geom_point(\n        aes(\n            x = bill_length_mm,\n            y = bill_depth_mm,\n            group = species,\n            color = species\n        )\n    ) +\n    geom_smooth(\n        aes(\n            x = bill_length_mm,\n            y = bill_depth_mm,\n            group = species,\n            color = species\n        )\n    ) +\n    theme_minimal()\n\n\n\n\n\n\n\n\nAs we can see, even for x and y, they do not have to be included in the ggplot() function. They can be included in the geom_*() functions.\n\n\n\n\n\nExercise\nThis exercise aims to show you a common pitall in using ggplot2 with global vs local assignment.\n\nWe want is to plot a smooth lines grouped by island, and the points are colored by species. Run the following code and see what went wrong.\n\n\nExerciseSolution\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nIssue: The smooth is working on species level, not on island level.\nCuause: geom_smooth took the color aesthetic from the global aes() function, and this messes up the local group aes, because color is inherentely a grouping aes.\n\n\n\n\n\nSolve the issue above.\n\n\nExerciseSolution\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n5.3.2 Global vs Local Data\nThis is slightly more advanced, but it is good to know that the data = * argument can be set globally or locally. For example, I want to have the points for all species, but only the trend line for the Gentoo species.\n\nlibrary(tidyverse)\nlibrary(palmerpenguins)\nggplot(\n    data = penguins,\n    aes(\n        x = bill_length_mm,\n        y = bill_depth_mm\n    ) \n) +\n    geom_point(aes(color = species)) + \n    geom_smooth(data = filter(penguins, species == \"Gentoo\")) + \n    theme_minimal()\n\n\n\n\n\n\n\n\nWe will explain what the filter() function does when we go to data wrangling. For now, just know that it is used to get the subset of data on species .",
    "crumbs": [
      "Grammar of Graphics",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>A Detailed Look at Grammar of Graphics</span>"
    ]
  }
]